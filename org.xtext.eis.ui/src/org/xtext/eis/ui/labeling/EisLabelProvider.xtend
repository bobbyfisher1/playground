/*
 * generated by Xtext 2.14.0
 */
package org.xtext.eis.ui.labeling

import com.google.inject.Inject
import org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider
import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider
import org.xtext.eis.eis.AssertionBlock
import org.xtext.eis.eis.Cascade
import org.xtext.eis.eis.Input
import org.xtext.eis.eis.Output
import org.xtext.eis.eis.Statement
import org.xtext.eis.eis.TeststepBlock
import org.xtext.eis.eis.Udt
import org.xtext.eis.eis.UdtRef
import org.xtext.eis.eis.Variable
import org.xtext.eis.eis.Variables

class EisLabelProvider extends DefaultEObjectLabelProvider {

	@Inject extension TypeRepresentation

	@Inject
	new(AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}

	def text(Input i) { "input" }

	def text(Output o) { "output" }

	def text(Variables v) {
		var inout = ""
		if (v instanceof Variable)
			v.name + " : " + v.trueVariableType
		else if (v instanceof Udt) {
			if(v.inout) inout = "inout "
			inout + "udt " + v.name + " of type " + v.udtType.name
		} else if (v instanceof UdtRef) {
			if(v.inout) inout = "inout "
			inout + "udt " + v.name + " of type " + v.udtType.name
		}
	}

	def text(AssertionBlock aBlock) {
		val plcCycle = (aBlock.eContainer as TeststepBlock).plcCycle.intValue
		val description = (aBlock.eContainer as TeststepBlock).description

		return "teststep " + plcCycle + "   " + description
	}

	def text(Statement st) {
		var name = st.variable.toString
		if (!st.cascade.empty)
			for (c : st.cascade)
				name += c

		return name + ' = ' + st.idiom.toString + ' +/- ' + st?.range.toString ?: ''
	}

	def text(Cascade cascade) {
		val statement = cascade.eContainer
		var name = (statement as Statement).variable.toString

		if (statement instanceof Statement) {
			if (!statement.cascade.empty)
				for (c : statement.cascade)
					name += c

			return name + ' = ' + statement.idiom.toString + ' +/- ' + statement?.range.toString ?: ''
		}
	}
}
