grammar org.example.eis.Eis with org.eclipse.xtext.common.Terminals

import 'http://www.eclipse.org/emf/2002/Ecore'
generate eis "http://www.example.org/eis/Eis"

EisModel:
	'project' '=' project_name=STRING ';'
	'plcname' '=' plc_name=STRING ';'
	'author' '=' author_name=STRING ';'
	testcases+=Testcase*;

Testcase:
	"testcase" testcase_name=ID '{'
	testblock=Testblock?
	'}';

Testblock:
	'testActive' '=' testActive=BoolConstant ';'
	'blockType' '=' blockType=BlockConstant ';'
	'description' '=' description=STRING ';'
	define=DefineBlock?;

BoolConstant:
	value=BooleanValue;

BlockConstant:
	value=BlockValue;

BlockValue:
	'FC' | 'FB';

BooleanValue:
	'true' | 'false';

DefineBlock:
	'define' '{' direction=DirectionBlock '}' teststeps+=TeststepBlock*;

DirectionBlock:
	input=Input & inout=InOut? & output=Output;

Input:
	name='input' '[' inputVariables+=Variables* ']';

Output:
	name='output' '[' outputVariables+=Variables* ']';

InOut:
	name='inout' '[' inoutVariables+=Variables* ']';

Variables:
	Variable | Udt | UdtRef;

Variable:
	({Variable} variantKeyword?='variant'? variableType=BasicType? name=ID ('=' idiom=Idiom ('+/-' range=Idiom)?)? (';' |
	nextVariable?=','));

Udt:
	'udt' name=ID '(' udtType=UdtType ')' '{' udtVariables+=Variables* '}';

UdtRef:
	udtType=[UdtType] name=ID udtVariables+=Variables* ';';

enum BasicType:
	NULL='null'
	| INT='int'
	| BOOL='bool'
	| REAL='real' // needs revision
	| STRING='string'
	| BYTE="byte"
	| WORD="word"
	| DWORD="dword"
	| LWORD="lword"
	//
	| USINT="usint"
	| UINT="uint"
	| UDINT="udint" // long type? + u&l Bss
	| ULINT="ulint" // ??????
	| SINT="sint"
	| DINT="dint" // normal int
	| LINT="lint" // normal long?
	//yet unimplemented
	| CHAR="char" //
	| TIME="time"
	| S5TIME="s5time";

UdtType:
	name=ID;

Idiom:
	Or;

Or returns Idiom:
	And ({Or.left=current} "||" right=And)*;

And returns Idiom:
	Equality ({And.left=current} "&&" right=Equality)*;

Equality returns Idiom:
	Comparison ({Equality.left=current} op=("==" | "!=") right=Comparison)*;

Comparison returns Idiom:
	PlusOrMinus ({Comparison.left=current} op=(">=" | "<=" | ">" | "<") right=PlusOrMinus)*;

PlusOrMinus returns Idiom:
	MulOrDiv (({Plus.left=current} '+' | {Minus.left=current} '-') right=MulOrDiv)*;

MulOrDiv returns Idiom:
	Primary ({MulOrDiv.left=current} op=('*' | '/') right=Primary)*;

Primary returns Idiom:
	'(' Idiom ')' | {Not} "!" idiom=Primary | Atomic;

Atomic returns Idiom:
	{IntConstant} value=INT
	| {StringConstant} value=STRING
	| BoolConstant
	| {VariableRef} variable=[Variable]
	| {RealConstant} value=REAL
	| {ByteConstant} value=BYTE
	| {WordConstant} value=WORD
	| {DWordConstant} value=DWORD
	| {LWordConstant} value=LWORD
	| {LongConstant} value=LONG;

TeststepBlock:
	'teststep' '(' plcCycle=INT ',' description=STRING ')' '{' assertion=AssertionBlock '}';

AssertionBlock:
	set=Set & assert=Assert;

Set:
	name='set' '[' setVariables+=Statement* ']';

Assert:
	name='assert' '[' assertVariables+=Statement* ']';

Statement:
	variable=[Variables] cascade+=Cascade* '=' idiom=Idiom ('+/-' range=Idiom)? ';';

Cascade:
	'.' udtVar=[Variables];

terminal fragment DIGIT:
	'0'..'9';

terminal fragment HEXDIGIT:
	DIGIT | 'A'..'F';

@Override
terminal INT returns EInt:
	'-'? DIGIT+;
	//
terminal LONG returns ELong:
	'-'? INT ('l' | 'L');
	//
terminal REAL returns EFloat:
	INT '.' DIGIT+;
	//
terminal BYTE:
	'16#' HEXDIGIT HEXDIGIT;
	//
terminal WORD:
	'16#' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT;
	//
terminal DWORD:
	'16#' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT '_' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT;
	//
terminal LWORD:
	'16#' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT '_' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT '_' HEXDIGIT HEXDIGIT HEXDIGIT
	HEXDIGIT '_' HEXDIGIT HEXDIGIT HEXDIGIT HEXDIGIT;



	
	
	
	
	
	
	
	
	
	
	
	
	
	
	