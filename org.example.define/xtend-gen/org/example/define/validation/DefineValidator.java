/**
 * generated by Xtext 2.14.0
 */
package org.example.define.validation;

import com.google.common.base.Objects;
import com.google.common.collect.HashMultimap;
import com.google.inject.Inject;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.example.define.define.And;
import org.example.define.define.Comparison;
import org.example.define.define.DefinePackage;
import org.example.define.define.DirectionBlock;
import org.example.define.define.Equality;
import org.example.define.define.Expression;
import org.example.define.define.Minus;
import org.example.define.define.MulOrDiv;
import org.example.define.define.Not;
import org.example.define.define.Or;
import org.example.define.define.Plus;
import org.example.define.define.Udt;
import org.example.define.define.Variable;
import org.example.define.typing.DefineType;
import org.example.define.typing.DefineTypeComputer;
import org.example.define.validation.AbstractDefineValidator;

@SuppressWarnings("all")
public class DefineValidator extends AbstractDefineValidator {
  protected final static String ISSUE_CODE_PREFIX = "org.example.entities.";
  
  public final static String MULTIPLE_VARIABLE_DECLARATION = (DefineValidator.ISSUE_CODE_PREFIX + "MultipleVariableDeclaration");
  
  public final static String MULTIPLE_UDT_DECLARATION = (DefineValidator.ISSUE_CODE_PREFIX + "MultipleUdtDeclaration");
  
  public final static String MISSING_VARIABLE_TYPE = (DefineValidator.ISSUE_CODE_PREFIX + "MissingVariableType");
  
  public final static String MULTIPLE_TYPE_DEFINITION = (DefineValidator.ISSUE_CODE_PREFIX + "MultipleTypeDefinition");
  
  public final static String INVALID_VARIANT_KEYWORD = (DefineValidator.ISSUE_CODE_PREFIX + "InvalidVariantKeyword");
  
  public final static String INVALID_COMMA_NOTATION = (DefineValidator.ISSUE_CODE_PREFIX + "InvalidCommaNotation");
  
  public final static String TYPE_MISMATCH = (DefineValidator.ISSUE_CODE_PREFIX + "TypeMismatch");
  
  public final static String INCOMPATIBLE_TYPES = (DefineValidator.ISSUE_CODE_PREFIX + "IncompatibleTypes");
  
  @Inject
  @Extension
  private DefineTypeComputer _defineTypeComputer;
  
  @Check
  public void checkNoDuplicateVariablesIO(final DirectionBlock directionblock) {
    final EList<Variable> in = directionblock.getInput().getInputVariables();
    final EList<Variable> out = directionblock.getOutput().getOutputVariables();
    final HashMultimap<String, Variable> multiMap = HashMultimap.<String, Variable>create();
    for (final Variable e : in) {
      {
        this.checkVariableTypeAndAddToMap(e, multiMap);
        Udt _udt = e.getUdt();
        if (_udt!=null) {
          this.checkAllVariableNamesInUdtScope(_udt);
        }
      }
    }
    for (final Variable e_1 : out) {
      {
        this.checkVariableTypeAndAddToMap(e_1, multiMap);
        Udt _udt = e_1.getUdt();
        if (_udt!=null) {
          this.checkAllVariableNamesInUdtScope(_udt);
        }
      }
    }
    Set<Map.Entry<String, Collection<Variable>>> _entrySet = multiMap.asMap().entrySet();
    for (final Map.Entry<String, Collection<Variable>> entry : _entrySet) {
      {
        final Collection<Variable> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final Variable d : duplicates) {
            this.checkVariableTypeAndCallError(d);
          }
        }
      }
    }
  }
  
  @Check
  public void checkNoDuplicateVariablesIOInout(final DirectionBlock directionblock) {
    final EList<Variable> in = directionblock.getInput().getInputVariables();
    final EList<Variable> out = directionblock.getOutput().getOutputVariables();
    final EList<Variable> inout = directionblock.getInout().getInoutVariables();
    final HashMultimap<String, Variable> multiMap = HashMultimap.<String, Variable>create();
    for (final Variable e : in) {
      {
        this.checkVariableTypeAndAddToMap(e, multiMap);
        Udt _udt = e.getUdt();
        if (_udt!=null) {
          this.checkAllVariableNamesInUdtScope(_udt);
        }
      }
    }
    for (final Variable e_1 : out) {
      {
        this.checkVariableTypeAndAddToMap(e_1, multiMap);
        Udt _udt = e_1.getUdt();
        if (_udt!=null) {
          this.checkAllVariableNamesInUdtScope(_udt);
        }
      }
    }
    for (final Variable e_2 : inout) {
      {
        this.checkVariableTypeAndAddToMap(e_2, multiMap);
        Udt _udt = e_2.getUdt();
        if (_udt!=null) {
          this.checkAllVariableNamesInUdtScope(_udt);
        }
      }
    }
    Set<Map.Entry<String, Collection<Variable>>> _entrySet = multiMap.asMap().entrySet();
    for (final Map.Entry<String, Collection<Variable>> entry : _entrySet) {
      {
        final Collection<Variable> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final Variable d : duplicates) {
            this.checkVariableTypeAndCallError(d);
          }
        }
      }
    }
  }
  
  @Check
  public void checkType(final Not not) {
    this.checkExpectedBoolean(not.getExpression(), DefinePackage.Literals.NOT__EXPRESSION);
  }
  
  @Check
  public void checkType(final And and) {
    this.checkExpectedBoolean(and.getLeft(), DefinePackage.Literals.AND__LEFT);
    this.checkExpectedBoolean(and.getRight(), DefinePackage.Literals.AND__RIGHT);
  }
  
  @Check
  public void checkType(final Or or) {
    this.checkExpectedBoolean(or.getLeft(), DefinePackage.Literals.OR__LEFT);
    this.checkExpectedBoolean(or.getRight(), DefinePackage.Literals.OR__RIGHT);
  }
  
  @Check
  public void checkType(final Minus minus) {
    this.checkExpectedInt(minus.getLeft(), DefinePackage.Literals.MINUS__LEFT);
    this.checkExpectedInt(minus.getRight(), DefinePackage.Literals.MINUS__RIGHT);
  }
  
  @Check
  public void checkType(final MulOrDiv mulOrDiv) {
    this.checkExpectedInt(mulOrDiv.getLeft(), DefinePackage.Literals.MUL_OR_DIV__LEFT);
    this.checkExpectedInt(mulOrDiv.getRight(), DefinePackage.Literals.MUL_OR_DIV__RIGHT);
  }
  
  @Check
  public void checkType(final Equality equality) {
    final DefineType leftType = this.getTypeAndCheckNotNull(equality.getLeft(), DefinePackage.Literals.EQUALITY__LEFT);
    final DefineType rightType = this.getTypeAndCheckNotNull(equality.getRight(), DefinePackage.Literals.EQUALITY__RIGHT);
    this.checkExpectedSameType(leftType, rightType);
  }
  
  @Check
  public void checkType(final Comparison comparison) {
    final DefineType leftType = this.getTypeAndCheckNotNull(comparison.getLeft(), DefinePackage.Literals.COMPARISON__LEFT);
    final DefineType rightType = this.getTypeAndCheckNotNull(comparison.getRight(), DefinePackage.Literals.COMPARISON__RIGHT);
    this.checkExpectedSameType(leftType, rightType);
    this.checkNotBoolean(leftType, DefinePackage.Literals.COMPARISON__LEFT);
    this.checkNotBoolean(rightType, DefinePackage.Literals.COMPARISON__RIGHT);
  }
  
  @Check
  public void checkType(final Plus plus) {
    final DefineType leftType = this.getTypeAndCheckNotNull(plus.getLeft(), DefinePackage.Literals.PLUS__LEFT);
    final DefineType rightType = this.getTypeAndCheckNotNull(plus.getRight(), DefinePackage.Literals.PLUS__RIGHT);
    if (((this._defineTypeComputer.isIntType(leftType) || this._defineTypeComputer.isIntType(rightType)) || ((!this._defineTypeComputer.isStringType(leftType)) && (!this._defineTypeComputer.isStringType(rightType))))) {
      this.checkNotBoolean(leftType, DefinePackage.Literals.PLUS__LEFT);
      this.checkNotBoolean(rightType, DefinePackage.Literals.PLUS__RIGHT);
    }
  }
  
  @Check
  public void checkType(final Variable v) {
    if (((v.getUdt() == null) && (v.getExpression() != null))) {
      Expression _expression = null;
      if (v!=null) {
        _expression=v.getExpression();
      }
      final DefineType actualType = this._defineTypeComputer.typeFor(_expression);
      final DefineType expectedType = this._defineTypeComputer.typeFor(v.getVariableType());
      Expression _range = null;
      if (v!=null) {
        _range=v.getRange();
      }
      DefineType _typeFor = null;
      if (_range!=null) {
        _typeFor=this._defineTypeComputer.typeFor(_range);
      }
      final DefineType rangeType = _typeFor;
      if (((expectedType == null) || (actualType == null))) {
        return;
      }
      boolean _notEquals = (!Objects.equal(expectedType, actualType));
      if (_notEquals) {
        String _string = expectedType.toString();
        String _plus = ("Incompatible types. Expected \'" + _string);
        String _plus_1 = (_plus + "\' but was \'");
        String _string_1 = actualType.toString();
        String _plus_2 = (_plus_1 + _string_1);
        String _plus_3 = (_plus_2 + 
          "\'");
        this.error(_plus_3, v, DefinePackage.eINSTANCE.getVariable_Expression(), DefineValidator.INCOMPATIBLE_TYPES);
      }
      if (((rangeType != null) && (!Objects.equal(rangeType, actualType)))) {
        String _string_2 = expectedType.toString();
        String _plus_4 = ("Incompatible types. Expected \'" + _string_2);
        String _plus_5 = (_plus_4 + "\' but was \'");
        String _string_3 = rangeType.toString();
        String _plus_6 = (_plus_5 + _string_3);
        String _plus_7 = (_plus_6 + "\'");
        this.error(_plus_7, v, DefinePackage.eINSTANCE.getVariable_Range(), DefineValidator.INCOMPATIBLE_TYPES);
      }
    }
  }
  
  private boolean checkVariableTypeAndAddToMap(final Variable e, final HashMultimap<String, Variable> multiMap) {
    boolean _xifexpression = false;
    Udt _udt = e.getUdt();
    boolean _tripleNotEquals = (_udt != null);
    if (_tripleNotEquals) {
      _xifexpression = multiMap.put(e.getUdt().getUdtName(), e);
    } else {
      _xifexpression = multiMap.put(e.getVariableName(), e);
    }
    return _xifexpression;
  }
  
  private void checkAllVariableNamesInUdtScope(final Udt udts) {
    final HashMultimap<String, Variable> newMultimap = HashMultimap.<String, Variable>create();
    final EList<Variable> udt = udts.getUdtVariables();
    for (final Variable e : udt) {
      {
        this.checkVariableTypeAndAddToMap(e, newMultimap);
        Udt _udt = e.getUdt();
        if (_udt!=null) {
          this.checkAllVariableNamesInUdtScope(_udt);
        }
      }
    }
    Set<Map.Entry<String, Collection<Variable>>> _entrySet = newMultimap.asMap().entrySet();
    for (final Map.Entry<String, Collection<Variable>> entry : _entrySet) {
      {
        final Collection<Variable> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final Variable d : duplicates) {
            this.checkVariableTypeAndCallError(d);
          }
        }
      }
    }
  }
  
  private void checkVariableTypeAndCallError(final Variable e) {
    Udt _udt = e.getUdt();
    boolean _tripleNotEquals = (_udt != null);
    if (_tripleNotEquals) {
      String _udtName = e.getUdt().getUdtName();
      String _plus = ("Multiple variable name \'" + _udtName);
      String _plus_1 = (_plus + "\'");
      this.error(_plus_1, e, DefinePackage.eINSTANCE.getVariable_Udt(), 
        DefineValidator.MULTIPLE_UDT_DECLARATION);
    } else {
      String _variableName = e.getVariableName();
      String _plus_2 = ("Multiple variable name \'" + _variableName);
      String _plus_3 = (_plus_2 + "\'");
      this.error(_plus_3, e, DefinePackage.eINSTANCE.getVariable_VariableName(), 
        DefineValidator.MULTIPLE_VARIABLE_DECLARATION);
    }
  }
  
  private void checkExpectedBoolean(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, DefineTypeComputer.BOOL_TYPE, reference);
  }
  
  private void checkExpectedInt(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, DefineTypeComputer.INT_TYPE, reference);
  }
  
  private void checkExpectedType(final Expression exp, final DefineType expectedType, final EReference reference) {
    final DefineType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(((("expected " + expectedType) + " type, but was ") + actualType), reference, DefineValidator.TYPE_MISMATCH);
    }
  }
  
  private DefineType getTypeAndCheckNotNull(final Expression exp, final EReference reference) {
    DefineType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._defineTypeComputer.typeFor(exp);
    }
    DefineType type = _typeFor;
    if ((type == null)) {
      this.error("null type", reference, DefineValidator.TYPE_MISMATCH);
    }
    return type;
  }
  
  private void checkExpectedSameType(final DefineType left, final DefineType right) {
    if ((((right != null) && (left != null)) && (!Objects.equal(right, left)))) {
      this.error(((("expected the same type, but was " + left) + ", ") + right), 
        DefinePackage.Literals.EQUALITY.getEIDAttribute(), DefineValidator.TYPE_MISMATCH);
    }
  }
  
  private void checkNotBoolean(final DefineType type, final EReference reference) {
    boolean _isBoolType = this._defineTypeComputer.isBoolType(type);
    if (_isBoolType) {
      this.error("cannot be boolean", reference, DefineValidator.TYPE_MISMATCH);
    }
  }
  
  @Check
  public void checkMatchBetweenTypeAndExpression() {
  }
  
  @Check
  public void checkUppercaseVariantName() {
  }
  
  @Check
  public void checkUppercaseUdtName() {
  }
  
  @Check
  public void checkLowercaseUdtType() {
  }
}
