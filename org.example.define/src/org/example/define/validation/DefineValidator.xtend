/*
 * generated by Xtext 2.14.0
 */
package org.example.define.validation

import com.google.common.collect.HashMultimap
import com.google.inject.Inject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check
import org.example.define.define.And
import org.example.define.define.BasicType
import org.example.define.define.Comparison
import org.example.define.define.DefinePackage
import org.example.define.define.DirectionBlock
import org.example.define.define.Equality
import org.example.define.define.Expression
import org.example.define.define.Inout
import org.example.define.define.Minus
import org.example.define.define.MulOrDiv
import org.example.define.define.Not
import org.example.define.define.Or
import org.example.define.define.Plus
import org.example.define.define.Udt
import org.example.define.define.Variable
import org.example.define.typing.DefineType
import org.example.define.typing.DefineTypeComputer

class DefineValidator extends AbstractDefineValidator {
	protected static val ISSUE_CODE_PREFIX = "org.example.entities.";
	public static val MULTIPLE_VARIABLE_DECLARATION = ISSUE_CODE_PREFIX + "MultipleVariableDeclaration"
	public static val MULTIPLE_UDT_DECLARATION = ISSUE_CODE_PREFIX + "MultipleUdtDeclaration"
	public static val MISSING_VARIABLE_TYPE = ISSUE_CODE_PREFIX + "MissingVariableType"
	public static val MULTIPLE_TYPE_DEFINITION = ISSUE_CODE_PREFIX + "MultipleTypeDefinition"
	public static val INVALID_VARIANT_KEYWORD = ISSUE_CODE_PREFIX + "InvalidVariantKeyword"
	public static val INVALID_COMMA_NOTATION = ISSUE_CODE_PREFIX + "InvalidCommaNotation"
	public static val TYPE_MISMATCH = ISSUE_CODE_PREFIX + "TypeMismatch"
	public static val INCOMPATIBLE_TYPES = ISSUE_CODE_PREFIX + "IncompatibleTypes"

	@Inject extension DefineTypeComputer

//
// checks -----------------------------------------------------------------------------------------------------------------------------------------------------------------
//
	@Check def void checkNoDuplicateVariablesIO(DirectionBlock directionblock) {
		val in = directionblock.input.inputVariables
		val out = directionblock.output.outputVariables
		val multiMap = HashMultimap.create()

		// add all variables to the map
		for (e : in) {
			e.checkVariableTypeAndAddToMap(multiMap)
			e.udt?.checkAllVariableNamesInUdtScope
		}

		for (e : out) {
			e.checkVariableTypeAndAddToMap(multiMap)
			e.udt?.checkAllVariableNamesInUdtScope
		}

		// check for duplicates
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					d.checkVariableTypeAndCallError
			}
		}
	}

	@Check def void checkNoDuplicateVariablesIOInout(DirectionBlock directionblock) {
		val in = directionblock.input.inputVariables
		val out = directionblock.output.outputVariables
		val inout = directionblock.inout.inoutVariables
		val multiMap = HashMultimap.create

		// add all variables to the multimap
		for (e : in) {
			e.checkVariableTypeAndAddToMap(multiMap)
			e.udt?.checkAllVariableNamesInUdtScope
		}
		for (e : out) {
			e.checkVariableTypeAndAddToMap(multiMap)
			e.udt?.checkAllVariableNamesInUdtScope
		}

		for (e : inout) {
			e.checkVariableTypeAndAddToMap(multiMap)
			e.udt?.checkAllVariableNamesInUdtScope
		}

		// check for duplicates
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					d.checkVariableTypeAndCallError
			}
		}
	}

	@Check def checkType(Not not) {
		checkExpectedBoolean(not.expression, DefinePackage.Literals.NOT__EXPRESSION)
	}

	@Check def checkType(And and) {
		checkExpectedBoolean(and.left, DefinePackage.Literals.AND__LEFT)
		checkExpectedBoolean(and.right, DefinePackage.Literals.AND__RIGHT)
	}

	@Check def checkType(Or or) {
		checkExpectedBoolean(or.left, DefinePackage.Literals.OR__LEFT)
		checkExpectedBoolean(or.right, DefinePackage.Literals.OR__RIGHT)
	}

	@Check def checkType(Minus minus) {
		checkExpectedInt(minus.left, DefinePackage.Literals.MINUS__LEFT)
		checkExpectedInt(minus.right, DefinePackage.Literals.MINUS__RIGHT)
	}

	@Check def checkType(MulOrDiv mulOrDiv) {
		checkExpectedInt(mulOrDiv.left, DefinePackage.Literals.MUL_OR_DIV__LEFT)
		checkExpectedInt(mulOrDiv.right, DefinePackage.Literals.MUL_OR_DIV__RIGHT)
	}

	@Check def checkType(Equality equality) {
		val leftType = getTypeAndCheckNotNull(equality.left, DefinePackage.Literals.EQUALITY__LEFT)
		val rightType = getTypeAndCheckNotNull(equality.right, DefinePackage.Literals.EQUALITY__RIGHT)
		checkExpectedSameType(leftType, rightType)
	}

	@Check def checkType(Comparison comparison) {
		val leftType = getTypeAndCheckNotNull(comparison.left, DefinePackage.Literals.COMPARISON__LEFT)
		val rightType = getTypeAndCheckNotNull(comparison.right, DefinePackage.Literals.COMPARISON__RIGHT)
		checkExpectedSameType(leftType, rightType)
		checkNotBoolean(leftType, DefinePackage.Literals.COMPARISON__LEFT)
		checkNotBoolean(rightType, DefinePackage.Literals.COMPARISON__RIGHT)
	}

	@Check def checkType(Plus plus) {
		val leftType = getTypeAndCheckNotNull(plus.left, DefinePackage.Literals.PLUS__LEFT)
		val rightType = getTypeAndCheckNotNull(plus.right, DefinePackage.Literals.PLUS__RIGHT)
		if (leftType.isIntType || rightType.isIntType || (!leftType.isStringType && !rightType.isStringType)) {
			checkNotBoolean(leftType, DefinePackage.Literals.PLUS__LEFT)
			checkNotBoolean(rightType, DefinePackage.Literals.PLUS__RIGHT)
		}
	}

	@Check def checkType(Variable v) {
		if (v.udt === null && v.expression !== null) {
			val actualType = v?.expression.typeFor
			val expectedType = v.variableType.typeFor
			val rangeType = v?.range?.typeFor

			if (expectedType === null || actualType === null)
				return;

			if (expectedType != actualType)
				error("Incompatible types. Expected '" + expectedType.toString + "' but was '" + actualType.toString +
					"'", v, DefinePackage.eINSTANCE.variable_Expression, INCOMPATIBLE_TYPES)

			if (rangeType !== null && rangeType != actualType)
				error(
					"Incompatible types. Expected '" + expectedType.toString + "' but was '" + rangeType.toString + "'",
					v, DefinePackage.eINSTANCE.variable_Range, INCOMPATIBLE_TYPES)

		}
	}

	@Check def void checkCommaSyntaxIO(DirectionBlock directionblock) {
		val in = directionblock.input.inputVariables
		val out = directionblock.output.outputVariables
		if (!in.empty) {
			checkCommaSyntaxWithVariables(in)
		}
		if (!out.empty) {
			checkCommaSyntaxWithVariables(out)
		}
	}

	@Check def void checkCommaSyntaxIOInout(Inout inouts) {
		val inout = inouts.inoutVariables
		if (!inout.empty) {
			checkCommaSyntaxWithVariables(inout)
		}
	}

//
// methods -----------------------------------------------------------------------------------------------------------------------------------------------------------------
//
	def private checkVariableTypeAndAddToMap(
		Variable e,
		HashMultimap<String, Variable> multiMap
	) {
		if (e.udt !== null) {
			multiMap.put(e.udt.udtName, e)
		} else
			multiMap.put(e.variableName, e)
	}

	def private checkAllVariableNamesInUdtScope(Udt udts) {
		val newMultimap = HashMultimap.create
		val udt = udts.udtVariables

		for (e : udt) {
			e.checkVariableTypeAndAddToMap(newMultimap)
			e.udt?.checkAllVariableNamesInUdtScope
		}
		// check for duplicates
		for (entry : newMultimap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					d.checkVariableTypeAndCallError
			}
		}
	}

	def private checkVariableTypeAndCallError(Variable e) {
		if (e.udt !== null)
			error("Multiple variable name '" + e.udt.udtName + "'", e, DefinePackage.eINSTANCE.variable_Udt,
				DefineValidator.MULTIPLE_UDT_DECLARATION)
		else // if (e.variableDefinition !== null)
			error("Multiple variable name '" + e.variableName + "'", e, DefinePackage.eINSTANCE.variable_VariableName,
				DefineValidator.MULTIPLE_VARIABLE_DECLARATION)
	}

	def private checkExpectedBoolean(Expression exp, EReference reference) {
		checkExpectedType(exp, DefineTypeComputer.BOOL_TYPE, reference)
	}

	def private checkExpectedInt(Expression exp, EReference reference) {
		checkExpectedType(exp, DefineTypeComputer.INT_TYPE, reference)
	}

	def private checkExpectedType(Expression exp, DefineType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("expected " + expectedType + " type, but was " + actualType, reference, TYPE_MISMATCH)
	}

	def private DefineType getTypeAndCheckNotNull(Expression exp, EReference reference) {
		var type = exp?.typeFor
		if (type === null)
			error("null type", reference, TYPE_MISMATCH)
		return type;
	}

	def private checkExpectedSameType(DefineType left, DefineType right) {
		if (right !== null && left !== null && right != left)
			error("expected the same type, but was " + left + ", " + right,
				DefinePackage.Literals.EQUALITY.EIDAttribute, TYPE_MISMATCH)
	}

	def private checkNotBoolean(DefineType type, EReference reference) {
		if (type.isBoolType)
			error("cannot be boolean", reference, TYPE_MISMATCH)
	}

	def private checkCommaSyntaxWithVariables(
		Iterable<? extends Variable> variables
	) {
		var count = 0 // ugly programming
		var countOfVariableBefore = 0
		var commaBeforeVariable = false;
		var helpingVariableType = BasicType.INT
		var variantKeyword = false
		//
		for (e : variables) {
			// refer error to the last variable which was succeeded by a comma
			if (commaBeforeVariable && (e.udt !== null)) {
				error("Invalid comma. Semicolon expected.", variables.get(countOfVariableBefore),
					DefinePackage.eINSTANCE.variable_NextVariable, INVALID_COMMA_NOTATION)
			}
			//
			if (e.udt === null) { // e is of type variable and not udt
				if ((count - countOfVariableBefore) > 1) {
					// this checks the case if there's a udt type between a comma and the expected inferred type
					commaBeforeVariable = false
				}

				if (!commaBeforeVariable) {
					if (e.variableType === BasicType.NULL) {
						error("Missing variable type", e, DefinePackage.eINSTANCE.variable_VariableType,
							MISSING_VARIABLE_TYPE);
					}
				} // else if there was a comma before the variable
				else {
					// assign inferred type 										
					if (e.variableType === BasicType.NULL) {
						e.variableType = helpingVariableType
					} // defined type after a comma
					else {
						error("Multiple type definition", e, DefinePackage.eINSTANCE.variable_VariableType,
							MULTIPLE_TYPE_DEFINITION)
					}
					// assign variantKeyword
					if (variantKeyword)
						e.variantKeyword = true
				}
				// for the immediate next variable
				if (e.nextVariable) { // comma at the end instead of semicolon
					commaBeforeVariable = true; // must be of type variable
					helpingVariableType = e.variableType // .basicType; // the type must be handed over to the next variable
					countOfVariableBefore = count;
					if (e.variantKeyword)
						variantKeyword = true
				} else {
					commaBeforeVariable = false
					helpingVariableType = null
					variantKeyword = false
				}
			}
			count++
		}
		// check if the last/only variable ends with a comma
		val last = variables.last
		if (last.udt === null && last.nextVariable)
			error("Invalid comma. Semicolon expected.", last, DefinePackage.eINSTANCE.variable_NextVariable,
				INVALID_COMMA_NOTATION)
	}

//
// yet unimplemented -----------------------------------------------------------------------------------------------------------------------------------------------------------------
//
	@Check def void checkMatchBetweenTypeAndExpression() {}

	@Check def void checkUppercaseVariantName() {}

	@Check def void checkUppercaseUdtName() {}

	@Check def void checkLowercaseUdtType() {}
}
