/**
 * generated by Xtext 2.14.0
 */
package org.xtext.eis.validation;

import com.google.common.base.Objects;
import com.google.common.collect.HashMultimap;
import com.google.inject.Inject;
import java.time.Duration;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeParseException;
import java.util.Collection;
import java.util.Map;
import java.util.Set;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.xtext.eis.eis.And;
import org.xtext.eis.eis.Assert;
import org.xtext.eis.eis.BasicType;
import org.xtext.eis.eis.BoolConstant;
import org.xtext.eis.eis.Cascade;
import org.xtext.eis.eis.Comparison;
import org.xtext.eis.eis.DefineBlock;
import org.xtext.eis.eis.DirectionBlock;
import org.xtext.eis.eis.EisModel;
import org.xtext.eis.eis.EisPackage;
import org.xtext.eis.eis.Equality;
import org.xtext.eis.eis.Idiom;
import org.xtext.eis.eis.Input;
import org.xtext.eis.eis.IntConstant;
import org.xtext.eis.eis.Minus;
import org.xtext.eis.eis.MulOrDiv;
import org.xtext.eis.eis.Not;
import org.xtext.eis.eis.Or;
import org.xtext.eis.eis.Plus;
import org.xtext.eis.eis.Statement;
import org.xtext.eis.eis.StringConstant;
import org.xtext.eis.eis.Testcase;
import org.xtext.eis.eis.TeststepBlock;
import org.xtext.eis.eis.Udt;
import org.xtext.eis.eis.UdtRef;
import org.xtext.eis.eis.Variable;
import org.xtext.eis.eis.VariableRef;
import org.xtext.eis.eis.Variables;
import org.xtext.eis.eis.impl.BoolConstantImpl;
import org.xtext.eis.eis.impl.IntConstantImpl;
import org.xtext.eis.eis.impl.StringConstantImpl;
import org.xtext.eis.eis.impl.UdtImpl;
import org.xtext.eis.eis.impl.VariableImpl;
import org.xtext.eis.interpreter.EisInterpreter;
import org.xtext.eis.typing.DefineType;
import org.xtext.eis.typing.DefineTypeComputer;
import org.xtext.eis.typing.types.DateType;
import org.xtext.eis.typing.types.LTimeType;
import org.xtext.eis.typing.types.TimeType;
import org.xtext.eis.validation.AbstractEisValidator;

@SuppressWarnings("all")
public class EisValidator extends AbstractEisValidator {
  protected final static String ISSUE_CODE_PREFIX = "org.example.entities.";
  
  public final static String MULTIPLE_VARIABLE_DECLARATION = (EisValidator.ISSUE_CODE_PREFIX + "MultipleVariableDeclaration");
  
  public final static String MULTIPLE_UDT_DECLARATION = (EisValidator.ISSUE_CODE_PREFIX + "MultipleUdtDeclaration");
  
  public final static String MISSING_VARIABLE_TYPE = (EisValidator.ISSUE_CODE_PREFIX + "MissingVariableType");
  
  public final static String MULTIPLE_TYPE_DEFINITION = (EisValidator.ISSUE_CODE_PREFIX + "MultipleTypeDefinition");
  
  public final static String INVALID_VARIANT_KEYWORD = (EisValidator.ISSUE_CODE_PREFIX + "InvalidVariantKeyword");
  
  public final static String INVALID_INOUT_KEYWORD = (EisValidator.ISSUE_CODE_PREFIX + "InvalidInOutKeyword");
  
  public final static String INVALID_COMMA_NOTATION = (EisValidator.ISSUE_CODE_PREFIX + "InvalidCommaNotation");
  
  public final static String TYPE_MISMATCH = (EisValidator.ISSUE_CODE_PREFIX + "TypeMismatch");
  
  public final static String INCOMPATIBLE_TYPES = (EisValidator.ISSUE_CODE_PREFIX + "IncompatibleTypes");
  
  public final static String NULL_REFERENCE = (EisValidator.ISSUE_CODE_PREFIX + "NullReference");
  
  public final static String MULTIPLE_UDT_TYPE = (EisValidator.ISSUE_CODE_PREFIX + "MultipleUdtType");
  
  public final static String VARIANT_MISMATCH = (EisValidator.ISSUE_CODE_PREFIX + "VariantMismatch");
  
  public final static String RECURSIVE_VARIABLE_REFERENCE = (EisValidator.ISSUE_CODE_PREFIX + "RecursiveVariableReference");
  
  public final static String RECURSIVE_UDT_REFERENCE = (EisValidator.ISSUE_CODE_PREFIX + "RecursiveUdtReference");
  
  public final static String MULTIPLE_STATEMENT_ASSIGNMENT = (EisValidator.ISSUE_CODE_PREFIX + "MultipleStatementAssignment");
  
  public final static String MISSING_UDT_REFERENCE = (EisValidator.ISSUE_CODE_PREFIX + "MissingUdtReference");
  
  public final static String INVALID_RANGE_DEFINITION = (EisValidator.ISSUE_CODE_PREFIX + "InvalidRangeDefinition");
  
  public final static String MULTIPLE_PLCCYCLE = (EisValidator.ISSUE_CODE_PREFIX + "MultiplePlcCycle");
  
  public final static String MULTIPLE_TESTCASE_NAME = (EisValidator.ISSUE_CODE_PREFIX + "MultipleTestcaseName");
  
  public final static String VALUE_EXCEEDING_DATATYPE_BOUNDS = (EisValidator.ISSUE_CODE_PREFIX + "ValueExceedingDatatypeBounds");
  
  public final static String DIVISION_BY_ZERO = (EisValidator.ISSUE_CODE_PREFIX + "DivisionByZero");
  
  public final static String NEGATIVE_PLCCYCLE = (EisValidator.ISSUE_CODE_PREFIX + "NegativePlcCycle");
  
  public final static String INVALID_UNDERSCORE_NOTATION = (EisValidator.ISSUE_CODE_PREFIX + "InvalidUnderscoreNotation");
  
  public final static String INVALID_DATE_NOTATION = (EisValidator.ISSUE_CODE_PREFIX + "InvalidDateNotation");
  
  @Inject
  @Extension
  private DefineTypeComputer _defineTypeComputer;
  
  @Inject
  @Extension
  private EisInterpreter _eisInterpreter;
  
  @Check
  public void checkNoDuplicateVariables(final DirectionBlock directionblock) {
    final EList<Variables> in = directionblock.getInput().getInputVariables();
    final EList<Variables> out = directionblock.getOutput().getOutputVariables();
    final HashMultimap<String, Variables> multiMap = HashMultimap.<String, Variables>create();
    for (final Variables e : in) {
      {
        this.checkVariableTypeAndAddToMap(e, multiMap);
        if ((e instanceof Udt)) {
          this.checkAllVariableNamesInUdtScope(((Udt)e));
        }
      }
    }
    for (final Variables e_1 : out) {
      {
        this.checkVariableTypeAndAddToMap(e_1, multiMap);
        if ((e_1 instanceof Udt)) {
          this.checkAllVariableNamesInUdtScope(((Udt)e_1));
        }
      }
    }
    Set<Map.Entry<String, Collection<Variables>>> _entrySet = multiMap.asMap().entrySet();
    for (final Map.Entry<String, Collection<Variables>> entry : _entrySet) {
      {
        final Collection<Variables> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final Variables d : duplicates) {
            this.checkVariableTypeAndCallError(d);
          }
        }
      }
    }
  }
  
  @Check
  public void checkNoDuplicateUdtTypes(final DirectionBlock directionblock) {
    HashMultimap<String, Udt> multiMap = HashMultimap.<String, Udt>create();
    final EList<Variables> in = directionblock.getInput().getInputVariables();
    final EList<Variables> out = directionblock.getOutput().getOutputVariables();
    for (final Variables e : in) {
      if ((e instanceof Udt)) {
        multiMap.put(((Udt)e).getUdtType().getName(), ((Udt)e));
        this.checkNoDuplicateUdtTypes(((Udt)e));
      }
    }
    for (final Variables e_1 : out) {
      if ((e_1 instanceof Udt)) {
        multiMap.put(((Udt)e_1).getUdtType().getName(), ((Udt)e_1));
        this.checkNoDuplicateUdtTypes(((Udt)e_1));
      }
    }
    Set<Map.Entry<String, Collection<Udt>>> _entrySet = multiMap.asMap().entrySet();
    for (final Map.Entry<String, Collection<Udt>> entry : _entrySet) {
      {
        final Collection<Udt> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final Udt d : duplicates) {
            String _name = ((Udt) d).getUdtType().getName();
            String _plus = ("Multiple udtType \'" + _name);
            String _plus_1 = (_plus + "\'");
            this.error(_plus_1, d, EisPackage.eINSTANCE.getUdt_UdtType(), 
              EisValidator.MULTIPLE_UDT_TYPE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkType(final Not not) {
    this.checkExpectedBoolean(not.getIdiom(), EisPackage.Literals.NOT__IDIOM);
  }
  
  @Check
  public void checkType(final And and) {
    this.checkExpectedBoolean(and.getLeft(), EisPackage.Literals.AND__LEFT);
    this.checkExpectedBoolean(and.getRight(), EisPackage.Literals.AND__RIGHT);
  }
  
  @Check
  public void checkType(final Or or) {
    this.checkExpectedBoolean(or.getLeft(), EisPackage.Literals.OR__LEFT);
    this.checkExpectedBoolean(or.getRight(), EisPackage.Literals.OR__RIGHT);
  }
  
  @Check
  public void checkType(final Minus minus) {
    final Object left = this._eisInterpreter.interpret(minus.getLeft());
    final Object right = this._eisInterpreter.interpret(minus.getRight());
    if (((left instanceof Double) || (right instanceof Double))) {
      this.checkExpectedDouble(minus.getLeft(), EisPackage.Literals.MINUS__LEFT);
      this.checkExpectedDouble(minus.getRight(), EisPackage.Literals.MINUS__RIGHT);
    } else {
      this.checkExpectedInt(minus.getLeft(), EisPackage.Literals.MINUS__LEFT);
      this.checkExpectedInt(minus.getRight(), EisPackage.Literals.MINUS__RIGHT);
    }
  }
  
  @Check
  public void checkType(final MulOrDiv mulOrDiv) {
    final Object left = this._eisInterpreter.interpret(mulOrDiv.getLeft());
    final Object right = this._eisInterpreter.interpret(mulOrDiv.getRight());
    if (((left instanceof Double) || (right instanceof Double))) {
      this.checkExpectedDouble(mulOrDiv.getRight(), EisPackage.Literals.MUL_OR_DIV__LEFT);
      this.checkExpectedDouble(mulOrDiv.getRight(), EisPackage.Literals.MUL_OR_DIV__RIGHT);
    } else {
      this.checkExpectedInt(mulOrDiv.getLeft(), EisPackage.Literals.MUL_OR_DIV__LEFT);
      this.checkExpectedInt(mulOrDiv.getRight(), EisPackage.Literals.MUL_OR_DIV__RIGHT);
    }
  }
  
  @Check
  public void checkDivisionByZero(final MulOrDiv mulOrDiv) {
    final Object right = this._eisInterpreter.interpret(mulOrDiv.getRight());
    if ((right instanceof Long)) {
      if ((((Long) right).longValue() == 0)) {
        this.error("Division by zero.", mulOrDiv, EisPackage.eINSTANCE.getMulOrDiv_Right(), EisValidator.DIVISION_BY_ZERO);
      }
    }
    if ((right instanceof Double)) {
      if ((((Double) right).doubleValue() == 0)) {
        this.error("Division by zero.", mulOrDiv, EisPackage.eINSTANCE.getMulOrDiv_Right(), EisValidator.DIVISION_BY_ZERO);
      }
    }
  }
  
  @Check
  public void checkType(final Equality equality) {
    final DefineType leftType = this.getTypeAndCheckNotNull(equality.getLeft(), EisPackage.Literals.EQUALITY__LEFT);
    final DefineType rightType = this.getTypeAndCheckNotNull(equality.getRight(), EisPackage.Literals.EQUALITY__RIGHT);
    this.checkExpectedSameType(leftType, rightType);
  }
  
  @Check
  public void checkType(final Comparison comparison) {
    final DefineType leftType = this.getTypeAndCheckNotNull(comparison.getLeft(), EisPackage.Literals.COMPARISON__LEFT);
    final DefineType rightType = this.getTypeAndCheckNotNull(comparison.getRight(), EisPackage.Literals.COMPARISON__RIGHT);
    this.checkExpectedSameType(leftType, rightType);
    this.checkNotBoolean(leftType, EisPackage.Literals.COMPARISON__LEFT);
    this.checkNotBoolean(rightType, EisPackage.Literals.COMPARISON__RIGHT);
  }
  
  @Check
  public void checkType(final Plus plus) {
    final DefineType leftType = this.getTypeAndCheckNotNull(plus.getLeft(), EisPackage.Literals.PLUS__LEFT);
    final DefineType rightType = this.getTypeAndCheckNotNull(plus.getRight(), EisPackage.Literals.PLUS__RIGHT);
    if (((this._defineTypeComputer.isIntSuperType(leftType) || this._defineTypeComputer.isIntSuperType(rightType)) || ((!this._defineTypeComputer.isStringType(leftType)) && (!this._defineTypeComputer.isStringType(rightType))))) {
      this.checkNotBoolean(leftType, EisPackage.Literals.PLUS__LEFT);
      this.checkNotBoolean(rightType, EisPackage.Literals.PLUS__RIGHT);
    }
  }
  
  @Check
  public void checkType(final Variable variable) {
    Idiom _idiom = variable.getIdiom();
    boolean _tripleNotEquals = (_idiom != null);
    if (_tripleNotEquals) {
      final DefineType expectedType = this._defineTypeComputer.typeFor(variable.getVariableType());
      Idiom _idiom_1 = null;
      if (variable!=null) {
        _idiom_1=variable.getIdiom();
      }
      final DefineType actualType = this._defineTypeComputer.typeFor(_idiom_1);
      Idiom _range = null;
      if (variable!=null) {
        _range=variable.getRange();
      }
      DefineType _typeFor = null;
      if (_range!=null) {
        _typeFor=this._defineTypeComputer.typeFor(_range);
      }
      final DefineType rangeType = _typeFor;
      if (((expectedType == null) || (actualType == null))) {
        return;
      }
      if ((expectedType != actualType)) {
        boolean _not = (!(this._defineTypeComputer.isIntSuperType(actualType) && this._defineTypeComputer.isIntSuperType(expectedType)));
        if (_not) {
          String _string = expectedType.toString();
          String _plus = ("Incompatible types. Expected \'" + _string);
          String _plus_1 = (_plus + "\' but was \'");
          String _string_1 = actualType.toString();
          String _plus_2 = (_plus_1 + _string_1);
          String _plus_3 = (_plus_2 + 
            "\'");
          this.error(_plus_3, variable, EisPackage.eINSTANCE.getVariable_Idiom(), EisValidator.INCOMPATIBLE_TYPES);
        }
      }
      if (((rangeType != null) && (!Objects.equal(rangeType, expectedType)))) {
        boolean _not_1 = (!(this._defineTypeComputer.isIntSuperType(rangeType) && this._defineTypeComputer.isIntSuperType(expectedType)));
        if (_not_1) {
          String _string_2 = expectedType.toString();
          String _plus_4 = ("Incompatible types. Expected \'" + _string_2);
          String _plus_5 = (_plus_4 + "\' but was \'");
          String _string_3 = rangeType.toString();
          String _plus_6 = (_plus_5 + _string_3);
          String _plus_7 = (_plus_6 + 
            "\'");
          this.error(_plus_7, variable, EisPackage.eINSTANCE.getVariable_Range(), EisValidator.INCOMPATIBLE_TYPES);
        }
      }
    }
  }
  
  @Check
  public void checkType(final Statement statement) {
    final EList<Cascade> cascade = statement.getCascade();
    final Variables variable = statement.getVariable();
    Cascade _last = null;
    if (cascade!=null) {
      _last=IterableExtensions.<Cascade>last(cascade);
    }
    Variables _udtVar = null;
    if (_last!=null) {
      _udtVar=_last.getUdtVar();
    }
    final Variables last = _udtVar;
    final DefineType actualType = this._defineTypeComputer.typeFor(statement.getIdiom());
    Idiom _range = null;
    if (statement!=null) {
      _range=statement.getRange();
    }
    DefineType _typeFor = null;
    if (_range!=null) {
      _typeFor=this._defineTypeComputer.typeFor(_range);
    }
    final DefineType rangeType = _typeFor;
    BasicType expectedType = BasicType.NULL;
    if ((variable instanceof Variable)) {
      expectedType = ((Variable) variable).getVariableType();
      this.compareTypesAndCallErrorOnMismatch(statement, actualType, expectedType, rangeType);
      if ((rangeType != null)) {
        if ((expectedType == BasicType.BOOL)) {
          this.error("The range feature is not permitted to boolean types", statement, 
            EisPackage.eINSTANCE.getStatement_Range(), EisValidator.INVALID_RANGE_DEFINITION);
        }
        if ((expectedType == BasicType.STRING)) {
          this.error("The range feature is not permitted to string types", statement, 
            EisPackage.eINSTANCE.getStatement_Range(), EisValidator.INVALID_RANGE_DEFINITION);
        }
      }
    } else {
      if ((last instanceof Variable)) {
        expectedType = ((Variable)last).getVariableType();
        this.compareTypesAndCallErrorOnMismatch(statement, actualType, expectedType, rangeType);
        if ((rangeType != null)) {
          if ((expectedType == BasicType.BOOL)) {
            this.error("The range feature is not permitted to boolean types", statement, 
              EisPackage.eINSTANCE.getStatement_Range(), EisValidator.INVALID_RANGE_DEFINITION);
          }
          if ((expectedType == BasicType.STRING)) {
            this.error("The range feature is not permitted to string types", statement, 
              EisPackage.eINSTANCE.getStatement_Range(), EisValidator.INVALID_RANGE_DEFINITION);
          }
        }
      }
    }
  }
  
  @Check
  public void checkCommaSyntax(final DirectionBlock directionblock) {
    final EList<Variables> in = directionblock.getInput().getInputVariables();
    final EList<Variables> out = directionblock.getOutput().getOutputVariables();
    boolean _isEmpty = in.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      this.checkCommaSyntaxWithVariables(in);
    }
    boolean _isEmpty_1 = out.isEmpty();
    boolean _not_1 = (!_isEmpty_1);
    if (_not_1) {
      this.checkCommaSyntaxWithVariables(out);
    }
  }
  
  @Check
  public void checkNullVariableRefs(final VariableRef varRef) {
    Idiom _idiom = varRef.getVariable().getIdiom();
    boolean _tripleEquals = (_idiom == null);
    if (_tripleEquals) {
      String _name = varRef.getVariable().getName();
      String _plus = ("Referred variable \'" + _name);
      String _plus_1 = (_plus + "\' is null.");
      this.error(_plus_1, varRef, 
        EisPackage.eINSTANCE.getVariableRef_Variable(), EisValidator.NULL_REFERENCE);
    }
  }
  
  @Check
  public void checkVariantWithRefs(final VariableRef varRef) {
    final EObject variable = varRef.eContainer();
    boolean _isVariantKeyword = ((Variable) variable).isVariantKeyword();
    boolean _isVariantKeyword_1 = varRef.getVariable().isVariantKeyword();
    boolean _tripleNotEquals = (Boolean.valueOf(_isVariantKeyword) != Boolean.valueOf(_isVariantKeyword_1));
    if (_tripleNotEquals) {
      this.error("Both variables must be variant types.", variable, EisPackage.eINSTANCE.getVariable_VariantKeyword(), 
        EisValidator.VARIANT_MISMATCH);
    }
  }
  
  @Check
  public void checkUdtRefs(final UdtRef udtRef) {
    EList<Variables> ownUdtVars = udtRef.getUdtVariables();
    EObject _eContainer = udtRef.getUdtType().eContainer();
    final EList<Variables> referredUdtVars = ((Udt) _eContainer).getUdtVariables();
    int count = 0;
    final boolean inoutKeyword = udtRef.isInout();
    ownUdtVars.clear();
    boolean _isEmpty = referredUdtVars.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      for (final Variables e : referredUdtVars) {
        {
          if ((e instanceof Variable)) {
            ownUdtVars.add(this.assignNewVariable(referredUdtVars, count, inoutKeyword));
          } else {
            if ((e instanceof Udt)) {
              ownUdtVars.add(this.assignNewUdt(referredUdtVars, count, inoutKeyword));
            } else {
              if ((e instanceof UdtRef)) {
                this.error("This reference cannot be made because the udt itself contains other references ", udtRef, 
                  EisPackage.eINSTANCE.getUdtRef_UdtType(), EisValidator.RECURSIVE_UDT_REFERENCE);
              }
            }
          }
          count++;
        }
      }
    }
  }
  
  @Check
  public void checkUdtStatements(final Statement statement) {
    if (((!(statement.getVariable() instanceof Variable)) && statement.getCascade().isEmpty())) {
      this.error("Only variables can be assigned to values", statement, EisPackage.eINSTANCE.getStatement_Variable(), 
        EisValidator.MISSING_UDT_REFERENCE);
    }
    final EList<Cascade> cascade = statement.getCascade();
    for (final Cascade c : cascade) {
      if (((!(c.getUdtVar() instanceof Variable)) && (c == IterableExtensions.<Cascade>last(cascade)))) {
        this.error("Only variables can be assigned to values", statement, EisPackage.eINSTANCE.getStatement_Cascade(), 
          EisValidator.MISSING_UDT_REFERENCE);
      }
    }
  }
  
  @Check
  public void checkMultipleStatementsSetBlock(final org.xtext.eis.eis.Set sets) {
    final EList<Statement> set = sets.getSetVariables();
    final HashMultimap<Object, Statement> multiMap = HashMultimap.<Object, Statement>create();
    Statement _head = null;
    if (set!=null) {
      _head=IterableExtensions.<Statement>head(set);
    }
    Variables _variable = null;
    if (_head!=null) {
      _variable=_head.getVariable();
    }
    String _string = null;
    if (_variable!=null) {
      _string=_variable.toString();
    }
    String name = _string;
    for (final Statement e : set) {
      boolean _isEmpty = e.getCascade().isEmpty();
      if (_isEmpty) {
        multiMap.put(e.getVariable(), e);
      } else {
        name = e.getVariable().toString();
        EList<Cascade> _cascade = e.getCascade();
        for (final Cascade c : _cascade) {
          String _name = name;
          String _string_1 = c.getUdtVar().toString();
          name = (_name + _string_1);
        }
        multiMap.put(name, e);
      }
    }
    Set<Map.Entry<Object, Collection<Statement>>> _entrySet = multiMap.asMap().entrySet();
    for (final Map.Entry<Object, Collection<Statement>> entry : _entrySet) {
      {
        final Collection<Statement> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final Statement d : duplicates) {
            boolean _isEmpty_1 = d.getCascade().isEmpty();
            if (_isEmpty_1) {
              this.error("Multiple variable assignment", d, EisPackage.eINSTANCE.getStatement_Variable(), 
                EisValidator.MULTIPLE_STATEMENT_ASSIGNMENT);
            } else {
              this.error("Multiple variable assignment", d, EisPackage.eINSTANCE.getStatement_Variable(), 
                EisValidator.MULTIPLE_STATEMENT_ASSIGNMENT);
              this.error("Multiple variable assignment", d, EisPackage.eINSTANCE.getStatement_Cascade(), 
                EisValidator.MULTIPLE_STATEMENT_ASSIGNMENT);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkMultipleStatementsAssertBlock(final Assert asserts) {
    final EList<Statement> assert_ = asserts.getAssertVariables();
    final HashMultimap<String, Statement> multiMap = HashMultimap.<String, Statement>create();
    String name = "";
    for (final Statement e : assert_) {
      boolean _isEmpty = e.getCascade().isEmpty();
      if (_isEmpty) {
        multiMap.put(e.getVariable().getName(), e);
      } else {
        name = e.getVariable().getName().toString();
        EList<Cascade> _cascade = e.getCascade();
        for (final Cascade c : _cascade) {
          String _name = name;
          String _string = c.getUdtVar().getName().toString();
          String _plus = ("." + _string);
          name = (_name + _plus);
        }
        multiMap.put(name, e);
      }
    }
    Set<Map.Entry<String, Collection<Statement>>> _entrySet = multiMap.asMap().entrySet();
    for (final Map.Entry<String, Collection<Statement>> entry : _entrySet) {
      {
        final Collection<Statement> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final Statement d : duplicates) {
            boolean _isEmpty_1 = d.getCascade().isEmpty();
            if (_isEmpty_1) {
              this.error("Multiple variable assignment", d, EisPackage.eINSTANCE.getStatement_Variable(), 
                EisValidator.MULTIPLE_STATEMENT_ASSIGNMENT);
            } else {
              this.error("Multiple variable assignment", d, EisPackage.eINSTANCE.getStatement_Variable(), 
                EisValidator.MULTIPLE_STATEMENT_ASSIGNMENT);
              this.error("Multiple variable assignment", d, EisPackage.eINSTANCE.getStatement_Cascade(), 
                EisValidator.MULTIPLE_STATEMENT_ASSIGNMENT);
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkRangeOperator(final Variable variable) {
    Idiom _range = variable.getRange();
    boolean _tripleNotEquals = (_range != null);
    if (_tripleNotEquals) {
      BasicType _variableType = variable.getVariableType();
      boolean _tripleEquals = (_variableType == BasicType.BOOL);
      if (_tripleEquals) {
        this.error("The range feature is not permitted to boolean types", variable, 
          EisPackage.eINSTANCE.getVariable_Range(), EisValidator.INVALID_RANGE_DEFINITION);
      }
      BasicType _variableType_1 = variable.getVariableType();
      boolean _tripleEquals_1 = (_variableType_1 == BasicType.STRING);
      if (_tripleEquals_1) {
        this.error("The range feature is not permitted to string types", variable, 
          EisPackage.eINSTANCE.getVariable_Range(), EisValidator.INVALID_RANGE_DEFINITION);
      }
      EObject _directionBlock = this.directionBlock(variable);
      if ((_directionBlock instanceof Input)) {
        this.error("The range feature is not permitted to input variables", variable, 
          EisPackage.eINSTANCE.getVariable_Range(), EisValidator.INVALID_RANGE_DEFINITION);
      }
    }
  }
  
  @Check
  public void checkRangeOperator(final org.xtext.eis.eis.Set set) {
    final EList<Statement> sets = set.getSetVariables();
    for (final Statement statement : sets) {
      Idiom _range = statement.getRange();
      boolean _tripleNotEquals = (_range != null);
      if (_tripleNotEquals) {
        this.error("The range feature is not permitted to input variables", statement, 
          EisPackage.eINSTANCE.getStatement_Range(), EisValidator.INVALID_RANGE_DEFINITION);
      }
    }
  }
  
  @Check
  public void checkUniquePlcCycles(final DefineBlock define) {
    HashMultimap<Long, TeststepBlock> multiMap = HashMultimap.<Long, TeststepBlock>create();
    EList<TeststepBlock> _teststeps = null;
    if (define!=null) {
      _teststeps=define.getTeststeps();
    }
    for (final TeststepBlock e : _teststeps) {
      multiMap.put(Long.valueOf(e.getPlcCycle()), e);
    }
    Set<Map.Entry<Long, Collection<TeststepBlock>>> _entrySet = multiMap.asMap().entrySet();
    for (final Map.Entry<Long, Collection<TeststepBlock>> entry : _entrySet) {
      {
        final Collection<TeststepBlock> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final TeststepBlock d : duplicates) {
            this.error("Multiple plcCycle", d, EisPackage.eINSTANCE.getTeststepBlock_PlcCycle(), 
              EisValidator.MULTIPLE_PLCCYCLE);
          }
        }
      }
    }
  }
  
  @Check
  public void checkUniqueTestcaseNames(final EisModel model) {
    HashMultimap<String, Testcase> multiMap = HashMultimap.<String, Testcase>create();
    EList<Testcase> _testcases = null;
    if (model!=null) {
      _testcases=model.getTestcases();
    }
    for (final Testcase e : _testcases) {
      multiMap.put(e.getTestcase_name(), e);
    }
    Set<Map.Entry<String, Collection<Testcase>>> _entrySet = multiMap.asMap().entrySet();
    for (final Map.Entry<String, Collection<Testcase>> entry : _entrySet) {
      {
        final Collection<Testcase> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final Testcase d : duplicates) {
            this.error("Multiple plcCycle", d, EisPackage.eINSTANCE.getTestcase_Testcase_name(), 
              EisValidator.MULTIPLE_TESTCASE_NAME);
          }
        }
      }
    }
  }
  
  @Check
  public void checkNumericalValues(final Variable variable) {
    final DefineType expectedType = this._defineTypeComputer.typeFor(variable.getVariableType());
    Idiom _idiom = null;
    if (variable!=null) {
      _idiom=variable.getIdiom();
    }
    final Idiom idiom = _idiom;
    Idiom _range = null;
    if (variable!=null) {
      _range=variable.getRange();
    }
    final Idiom range = _range;
    if ((idiom != null)) {
      if ((!(idiom instanceof VariableRef))) {
        final Object idiomValue = this._eisInterpreter.interpret(idiom);
        if ((idiomValue instanceof Long)) {
          boolean _checkNumericalValues = this.checkNumericalValues(((Long) idiomValue).longValue(), expectedType);
          if (_checkNumericalValues) {
            this.error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.getVariable_Idiom(), 
              EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
          }
        }
      }
    }
    if ((range != null)) {
      if ((!(range instanceof VariableRef))) {
        final Object rangeValue = this._eisInterpreter.interpret(range);
        if ((rangeValue instanceof Long)) {
          boolean _checkNumericalValues_1 = this.checkNumericalValues(((Long) rangeValue).longValue(), expectedType);
          if (_checkNumericalValues_1) {
            this.error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.getVariable_Range(), 
              EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
          }
        }
      }
    }
  }
  
  @Check
  public void checkValuesOfStatements(final Statement statement) {
    final EList<Cascade> cascade = statement.getCascade();
    final Variables variable = statement.getVariable();
    Cascade _last = null;
    if (cascade!=null) {
      _last=IterableExtensions.<Cascade>last(cascade);
    }
    Variables _udtVar = null;
    if (_last!=null) {
      _udtVar=_last.getUdtVar();
    }
    final Variables last = _udtVar;
    Idiom _idiom = null;
    if (statement!=null) {
      _idiom=statement.getIdiom();
    }
    final Idiom idiom = _idiom;
    Idiom _range = null;
    if (statement!=null) {
      _range=statement.getRange();
    }
    final Idiom range = _range;
    DefineType expectedType = this._defineTypeComputer.typeFor(BasicType.NULL);
    if ((variable instanceof Variable)) {
      expectedType = this._defineTypeComputer.typeFor(((Variable)variable).getVariableType());
      if ((!(idiom instanceof VariableRef))) {
        final Object idiomValue = this._eisInterpreter.interpret(idiom);
        if ((idiomValue instanceof Long)) {
          boolean _checkNumericalValues = this.checkNumericalValues(((Long) idiomValue).longValue(), expectedType);
          if (_checkNumericalValues) {
            this.error("Value is out of the datatype boundaries.", statement, 
              EisPackage.eINSTANCE.getStatement_Idiom(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
          }
        } else {
          DefineType _typeFor = this._defineTypeComputer.typeFor(idiom);
          if ((_typeFor instanceof TimeType)) {
            boolean _checkTime = this.checkTime(idiom);
            if (_checkTime) {
              this.error("Value is out of the datatype boundaries.", statement, 
                EisPackage.eINSTANCE.getStatement_Idiom(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
            }
            this.checkUnderscoreNotation(this._eisInterpreter.interpret(idiom).toString(), statement, EisPackage.eINSTANCE.getStatement_Idiom());
          } else {
            DefineType _typeFor_1 = this._defineTypeComputer.typeFor(idiom);
            if ((_typeFor_1 instanceof LTimeType)) {
              boolean _isOutOfLTime = this.isOutOfLTime(idiom);
              if (_isOutOfLTime) {
                this.error("Value is out of the datatype boundaries.", statement, 
                  EisPackage.eINSTANCE.getStatement_Idiom(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
              }
              this.checkUnderscoreNotation(this._eisInterpreter.interpret(idiom).toString(), statement, EisPackage.eINSTANCE.getStatement_Idiom());
            } else {
              DefineType _typeFor_2 = this._defineTypeComputer.typeFor(idiom);
              if ((_typeFor_2 instanceof DateType)) {
                boolean _checkDate = this.checkDate(idiom, EisPackage.eINSTANCE.getStatement_Idiom());
                if (_checkDate) {
                  this.error("Value is out of the datatype boundaries.", statement, 
                    EisPackage.eINSTANCE.getStatement_Idiom(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
                }
              }
            }
          }
        }
      }
      if ((range != null)) {
        if ((!(range instanceof VariableRef))) {
          final Object rangeValue = this._eisInterpreter.interpret(range);
          if ((rangeValue instanceof Long)) {
            boolean _checkNumericalValues_1 = this.checkNumericalValues(((Long) rangeValue).longValue(), expectedType);
            if (_checkNumericalValues_1) {
              this.error("Value is out of the datatype boundaries.", statement, 
                EisPackage.eINSTANCE.getStatement_Range(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
            }
          } else {
            DefineType _typeFor_3 = this._defineTypeComputer.typeFor(range);
            if ((_typeFor_3 instanceof TimeType)) {
              boolean _checkTime_1 = this.checkTime(range);
              if (_checkTime_1) {
                this.error("Value is out of the datatype boundaries.", statement, 
                  EisPackage.eINSTANCE.getStatement_Range(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
              }
              this.checkUnderscoreNotation(this._eisInterpreter.interpret(range).toString(), statement, 
                EisPackage.eINSTANCE.getStatement_Range());
            } else {
              DefineType _typeFor_4 = this._defineTypeComputer.typeFor(range);
              if ((_typeFor_4 instanceof LTimeType)) {
                boolean _isOutOfLTime_1 = this.isOutOfLTime(range);
                if (_isOutOfLTime_1) {
                  this.error("Value is out of the datatype boundaries.", statement, 
                    EisPackage.eINSTANCE.getStatement_Range(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
                }
                this.checkUnderscoreNotation(this._eisInterpreter.interpret(range).toString(), statement, 
                  EisPackage.eINSTANCE.getStatement_Range());
              } else {
                DefineType _typeFor_5 = this._defineTypeComputer.typeFor(range);
                if ((_typeFor_5 instanceof DateType)) {
                  this.error("The range feature is not permitted to dates.", statement, 
                    EisPackage.eINSTANCE.getStatement_Range(), EisValidator.INVALID_RANGE_DEFINITION);
                }
              }
            }
          }
        }
      }
    } else {
      if ((last instanceof Variable)) {
        expectedType = this._defineTypeComputer.typeFor(((Variable)last).getVariableType());
        if ((!(idiom instanceof VariableRef))) {
          final Object idiomValue_1 = this._eisInterpreter.interpret(idiom);
          if ((idiomValue_1 instanceof Long)) {
            boolean _checkNumericalValues_2 = this.checkNumericalValues(((Long) idiomValue_1).longValue(), expectedType);
            if (_checkNumericalValues_2) {
              this.error("Value is out of the datatype boundaries.", statement, 
                EisPackage.eINSTANCE.getStatement_Idiom(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
            }
          } else {
            DefineType _typeFor_6 = this._defineTypeComputer.typeFor(idiom);
            if ((_typeFor_6 instanceof TimeType)) {
              boolean _checkTime_2 = this.checkTime(idiom);
              if (_checkTime_2) {
                this.error("Value is out of the datatype boundaries.", statement, 
                  EisPackage.eINSTANCE.getStatement_Idiom(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
              }
              this.checkUnderscoreNotation(this._eisInterpreter.interpret(idiom).toString(), statement, EisPackage.eINSTANCE.getStatement_Idiom());
            } else {
              DefineType _typeFor_7 = this._defineTypeComputer.typeFor(idiom);
              if ((_typeFor_7 instanceof LTimeType)) {
                boolean _isOutOfLTime_2 = this.isOutOfLTime(idiom);
                if (_isOutOfLTime_2) {
                  this.error("Value is out of the datatype boundaries.", statement, 
                    EisPackage.eINSTANCE.getStatement_Idiom(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
                }
                this.checkUnderscoreNotation(this._eisInterpreter.interpret(idiom).toString(), statement, EisPackage.eINSTANCE.getStatement_Idiom());
              } else {
                DefineType _typeFor_8 = this._defineTypeComputer.typeFor(idiom);
                if ((_typeFor_8 instanceof DateType)) {
                  boolean _checkDate_1 = this.checkDate(idiom, EisPackage.eINSTANCE.getStatement_Idiom());
                  if (_checkDate_1) {
                    this.error("Value is out of the datatype boundaries.", statement, 
                      EisPackage.eINSTANCE.getStatement_Idiom(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
                  }
                }
              }
            }
          }
        }
        if ((range != null)) {
          if ((!(range instanceof VariableRef))) {
            final Object rangeValue_1 = this._eisInterpreter.interpret(range);
            if ((rangeValue_1 instanceof Long)) {
              boolean _checkNumericalValues_3 = this.checkNumericalValues(((Long) rangeValue_1).longValue(), expectedType);
              if (_checkNumericalValues_3) {
                this.error("Value is out of the datatype boundaries.", statement, 
                  EisPackage.eINSTANCE.getStatement_Range(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
              }
            } else {
              DefineType _typeFor_9 = this._defineTypeComputer.typeFor(range);
              if ((_typeFor_9 instanceof TimeType)) {
                boolean _checkTime_3 = this.checkTime(range);
                if (_checkTime_3) {
                  this.error("Value is out of the datatype boundaries.", statement, 
                    EisPackage.eINSTANCE.getStatement_Range(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
                }
                this.checkUnderscoreNotation(this._eisInterpreter.interpret(range).toString(), statement, 
                  EisPackage.eINSTANCE.getStatement_Range());
              } else {
                DefineType _typeFor_10 = this._defineTypeComputer.typeFor(range);
                if ((_typeFor_10 instanceof LTimeType)) {
                  boolean _isOutOfLTime_3 = this.isOutOfLTime(range);
                  if (_isOutOfLTime_3) {
                    this.error("Value is out of the datatype boundaries.", statement, 
                      EisPackage.eINSTANCE.getStatement_Range(), EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
                  }
                  this.checkUnderscoreNotation(this._eisInterpreter.interpret(range).toString(), statement, 
                    EisPackage.eINSTANCE.getStatement_Range());
                } else {
                  DefineType _typeFor_11 = this._defineTypeComputer.typeFor(range);
                  if ((_typeFor_11 instanceof DateType)) {
                    this.error("The range feature is not permitted to dates.", statement, 
                      EisPackage.eINSTANCE.getStatement_Range(), EisValidator.INVALID_RANGE_DEFINITION);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  
  @Check
  public void checkTimeValues(final Variable variable) {
    Idiom _idiom = null;
    if (variable!=null) {
      _idiom=variable.getIdiom();
    }
    final Idiom idiom = _idiom;
    Idiom _range = null;
    if (variable!=null) {
      _range=variable.getRange();
    }
    final Idiom range = _range;
    if ((idiom != null)) {
      if ((!(idiom instanceof VariableRef))) {
        DefineType _typeFor = this._defineTypeComputer.typeFor(idiom);
        if ((_typeFor instanceof TimeType)) {
          boolean _checkTime = this.checkTime(idiom);
          if (_checkTime) {
            this.error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.getVariable_Idiom(), 
              EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
          }
          this.checkUnderscoreNotation(this._eisInterpreter.interpret(idiom).toString(), variable, EisPackage.eINSTANCE.getVariable_Idiom());
        } else {
          DefineType _typeFor_1 = this._defineTypeComputer.typeFor(idiom);
          if ((_typeFor_1 instanceof LTimeType)) {
            boolean _isOutOfLTime = this.isOutOfLTime(idiom);
            if (_isOutOfLTime) {
              this.error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.getVariable_Idiom(), 
                EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
            }
            this.checkUnderscoreNotation(this._eisInterpreter.interpret(idiom).toString(), variable, EisPackage.eINSTANCE.getVariable_Idiom());
          }
        }
      }
    }
    if ((range != null)) {
      if ((!(range instanceof VariableRef))) {
        DefineType _typeFor_2 = this._defineTypeComputer.typeFor(range);
        if ((_typeFor_2 instanceof TimeType)) {
          boolean _checkTime_1 = this.checkTime(range);
          if (_checkTime_1) {
            this.error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.getVariable_Range(), 
              EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
          }
          this.checkUnderscoreNotation(this._eisInterpreter.interpret(range).toString(), variable, EisPackage.eINSTANCE.getVariable_Range());
        } else {
          DefineType _typeFor_3 = this._defineTypeComputer.typeFor(range);
          if ((_typeFor_3 instanceof LTimeType)) {
            boolean _isOutOfLTime_1 = this.isOutOfLTime(range);
            if (_isOutOfLTime_1) {
              this.error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.getVariable_Range(), 
                EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
            }
            this.checkUnderscoreNotation(this._eisInterpreter.interpret(range).toString(), variable, EisPackage.eINSTANCE.getVariable_Range());
          }
        }
      }
    }
  }
  
  @Check
  public void checkInoutKeyword(final Variables variable) {
    boolean _isInout = variable.isInout();
    if (_isInout) {
      EObject _eContainer = variable.eContainer();
      if ((_eContainer instanceof Udt)) {
        EObject _firstUdt = this.firstUdt(variable);
        boolean _isInout_1 = ((Udt) _firstUdt).isInout();
        boolean _not = (!_isInout_1);
        if (_not) {
          this.error("Invalid inout keyword", variable, EisPackage.eINSTANCE.getVariables_Inout(), 
            EisValidator.INVALID_INOUT_KEYWORD);
        }
      }
      if ((variable instanceof Udt)) {
        this.assignInOutKeywordToAll(((Udt)variable).getUdtVariables());
      }
    }
  }
  
  @Check
  public void checkDateValues(final Variable variable) {
    Idiom _idiom = null;
    if (variable!=null) {
      _idiom=variable.getIdiom();
    }
    final Idiom idiom = _idiom;
    Idiom _range = null;
    if (variable!=null) {
      _range=variable.getRange();
    }
    final Idiom range = _range;
    if ((idiom != null)) {
      if ((!(idiom instanceof VariableRef))) {
        DefineType _typeFor = this._defineTypeComputer.typeFor(idiom);
        if ((_typeFor instanceof DateType)) {
          boolean _checkDate = this.checkDate(idiom, EisPackage.eINSTANCE.getVariable_Idiom());
          if (_checkDate) {
            this.error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.getVariable_Idiom(), 
              EisValidator.VALUE_EXCEEDING_DATATYPE_BOUNDS);
          }
        }
      }
    }
    if ((range != null)) {
      if ((!(range instanceof VariableRef))) {
        DefineType _typeFor_1 = this._defineTypeComputer.typeFor(range);
        if ((_typeFor_1 instanceof DateType)) {
          this.error("The range feature is not permitted to dates.", variable, EisPackage.eINSTANCE.getVariable_Range(), 
            EisValidator.INVALID_RANGE_DEFINITION);
        }
      }
    }
  }
  
  public boolean checkDate(final Idiom _date, final EReference ref) {
    boolean _xblockexpression = false;
    {
      final String date = this._eisInterpreter.interpret(_date).toString().substring(2);
      final int dateAsInt = Integer.parseInt(date.replaceAll("-", ""));
      final int upperBound = 21690606;
      final int lowerBound = 19900101;
      try {
        LocalDate.parse(date, DateTimeFormatter.ISO_LOCAL_DATE);
      } catch (final Throwable _t) {
        if (_t instanceof DateTimeParseException) {
          this.error("Date could not be correctly parsed.", _date.eContainer(), ref, EisValidator.INVALID_DATE_NOTATION);
          return false;
        } else {
          throw Exceptions.sneakyThrow(_t);
        }
      }
      boolean _xifexpression = false;
      if (((dateAsInt < lowerBound) || (dateAsInt > upperBound))) {
        return true;
      } else {
        _xifexpression = false;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  private EObject firstUdt(final EObject context) {
    EObject _xblockexpression = null;
    {
      final EObject container = context.eContainer();
      EObject _xifexpression = null;
      if ((container instanceof Udt)) {
        _xifexpression = this.firstUdt(container);
      } else {
        return context;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public void assignInOutKeywordToAll(final EList<Variables> udtVariables) {
    for (final Variables variable : udtVariables) {
      if ((variable instanceof Variable)) {
        ((Variable)variable).setInout(true);
      } else {
        if ((variable instanceof Udt)) {
          ((Udt)variable).setInout(true);
          this.assignInOutKeywordToAll(((Udt)variable).getUdtVariables());
        } else {
          if ((variable instanceof UdtRef)) {
            ((UdtRef)variable).setInout(true);
            this.assignInOutKeywordToAll(((UdtRef)variable).getUdtVariables());
          }
        }
      }
    }
  }
  
  public boolean checkTime(final Idiom _time) {
    boolean _xblockexpression = false;
    {
      String time = this._eisInterpreter.interpret(_time).toString().substring(2).replaceAll("_", "");
      String ms = "";
      String s = "";
      String m = "";
      String h = "";
      String d = "";
      String sign = "";
      boolean _contains = time.contains("-");
      if (_contains) {
        sign = "-";
        time = time.replace("-", "");
      }
      boolean _contains_1 = time.contains("ms");
      if (_contains_1) {
        time = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(time.split("ms"))));
        ms = this.lastNumber(time);
      }
      boolean _contains_2 = time.contains("s");
      if (_contains_2) {
        time = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(time.split("s"))));
        s = this.lastNumber(time);
      }
      boolean _contains_3 = time.contains("m");
      if (_contains_3) {
        time = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(time.split("m"))));
        m = this.lastNumber(time);
      }
      boolean _contains_4 = time.contains("h");
      if (_contains_4) {
        time = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(time.split("h"))));
        h = this.lastNumber(time);
      }
      boolean _contains_5 = time.contains("d");
      if (_contains_5) {
        d = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(time.split("d"))));
      }
      time = (sign + "p");
      boolean _notEquals = (!Objects.equal(d, ""));
      if (_notEquals) {
        String _time_1 = time;
        time = (_time_1 + (d + "d"));
      }
      String _time_2 = time;
      time = (_time_2 + "t");
      boolean _notEquals_1 = (!Objects.equal(h, ""));
      if (_notEquals_1) {
        String _time_3 = time;
        time = (_time_3 + (h + "h"));
      }
      boolean _notEquals_2 = (!Objects.equal(m, ""));
      if (_notEquals_2) {
        String _time_4 = time;
        time = (_time_4 + (m + "m"));
      }
      boolean _notEquals_3 = (!Objects.equal(s, ""));
      if (_notEquals_3) {
        String _time_5 = time;
        time = (_time_5 + s);
        boolean _notEquals_4 = (!Objects.equal(ms, ""));
        if (_notEquals_4) {
          String _time_6 = time;
          String _fraction = this.fraction(ms);
          String _plus = ("." + _fraction);
          time = (_time_6 + _plus);
        }
        String _time_7 = time;
        time = (_time_7 + "s");
      } else {
        boolean _notEquals_5 = (!Objects.equal(ms, ""));
        if (_notEquals_5) {
          String _time_8 = time;
          String _fraction_1 = this.fraction(ms);
          String _plus_1 = (("0" + ".") + _fraction_1);
          String _plus_2 = (_plus_1 + "s");
          time = (_time_8 + _plus_2);
        }
      }
      final Duration duration = Duration.parse(time);
      final Duration maxTime = Duration.parse("p24dt20h31m23,647s");
      final Duration minTime = Duration.parse("-p24dt20h31m23,648s");
      boolean _xifexpression = false;
      int _compareTo = maxTime.compareTo(duration);
      boolean _lessThan = (_compareTo < 0);
      if (_lessThan) {
        return true;
      } else {
        boolean _xifexpression_1 = false;
        int _compareTo_1 = minTime.compareTo(duration);
        boolean _greaterThan = (_compareTo_1 > 0);
        if (_greaterThan) {
          return true;
        } else {
          _xifexpression_1 = false;
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public boolean isOutOfLTime(final Idiom _ltime) {
    boolean _xblockexpression = false;
    {
      String LTime = this._eisInterpreter.interpret(_ltime).toString().substring(3).replaceAll("_", "");
      String ns = "";
      String us = "";
      String ms = "";
      String s = "";
      String m = "";
      String h = "";
      String d = "";
      String sign = "";
      boolean _contains = LTime.contains("-");
      if (_contains) {
        sign = "-";
        LTime = LTime.replace("-", "");
      }
      boolean _contains_1 = LTime.contains("ns");
      if (_contains_1) {
        LTime = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(LTime.split("ns"))));
        ns = this.lastNumber(LTime);
      }
      boolean _contains_2 = LTime.contains("us");
      if (_contains_2) {
        LTime = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(LTime.split("us"))));
        us = this.lastNumber(LTime);
      }
      boolean _contains_3 = LTime.contains("ms");
      if (_contains_3) {
        LTime = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(LTime.split("ms"))));
        ms = this.lastNumber(LTime);
      }
      boolean _contains_4 = LTime.contains("s");
      if (_contains_4) {
        LTime = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(LTime.split("s"))));
        s = this.lastNumber(LTime);
      }
      boolean _contains_5 = LTime.contains("m");
      if (_contains_5) {
        LTime = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(LTime.split("m"))));
        m = this.lastNumber(LTime);
      }
      boolean _contains_6 = LTime.contains("h");
      if (_contains_6) {
        LTime = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(LTime.split("h"))));
        h = this.lastNumber(LTime);
      }
      boolean _contains_7 = LTime.contains("d");
      if (_contains_7) {
        d = IterableExtensions.<String>head(((Iterable<String>)Conversions.doWrapArray(LTime.split("d"))));
      }
      LTime = (sign + "p");
      boolean _notEquals = (!Objects.equal(d, ""));
      if (_notEquals) {
        String _LTime = LTime;
        LTime = (_LTime + (d + "d"));
      }
      String _LTime_1 = LTime;
      LTime = (_LTime_1 + "t");
      boolean _notEquals_1 = (!Objects.equal(h, ""));
      if (_notEquals_1) {
        String _LTime_2 = LTime;
        LTime = (_LTime_2 + (h + "h"));
      }
      boolean _notEquals_2 = (!Objects.equal(m, ""));
      if (_notEquals_2) {
        String _LTime_3 = LTime;
        LTime = (_LTime_3 + (m + "m"));
      }
      boolean _notEquals_3 = (!Objects.equal(s, ""));
      if (_notEquals_3) {
        String _LTime_4 = LTime;
        LTime = (_LTime_4 + s);
        if ((((!Objects.equal(ns, "")) || (!Objects.equal(us, ""))) || (!Objects.equal(ms, "")))) {
          String _LTime_5 = LTime;
          String _fraction = this.fraction(ms);
          String _plus = ("." + _fraction);
          String _fraction_1 = this.fraction(us);
          String _plus_1 = (_plus + _fraction_1);
          String _fraction_2 = this.fraction(ns);
          String _plus_2 = (_plus_1 + _fraction_2);
          LTime = (_LTime_5 + _plus_2);
        }
        String _LTime_6 = LTime;
        LTime = (_LTime_6 + "s");
      } else {
        if ((((!Objects.equal(ns, "")) || (!Objects.equal(us, ""))) || (!Objects.equal(ms, "")))) {
          String _LTime_7 = LTime;
          String _fraction_3 = this.fraction(ms);
          String _plus_3 = ("0." + _fraction_3);
          String _fraction_4 = this.fraction(us);
          String _plus_4 = (_plus_3 + _fraction_4);
          String _fraction_5 = this.fraction(ns);
          String _plus_5 = (_plus_4 + _fraction_5);
          String _plus_6 = (_plus_5 + "s");
          LTime = (_LTime_7 + _plus_6);
        }
      }
      final Duration duration = Duration.parse(LTime);
      final Duration maxTime = Duration.parse("p106751dt23h47m16.854775807s");
      final Duration minTime = Duration.parse("-p106751dt23h47m16.854775808s");
      boolean _xifexpression = false;
      int _compareTo = maxTime.compareTo(duration);
      boolean _lessThan = (_compareTo < 0);
      if (_lessThan) {
        return true;
      } else {
        boolean _xifexpression_1 = false;
        int _compareTo_1 = minTime.compareTo(duration);
        boolean _greaterThan = (_compareTo_1 > 0);
        if (_greaterThan) {
          return true;
        } else {
          _xifexpression_1 = false;
        }
        _xifexpression = _xifexpression_1;
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  public String lastNumber(final String time) {
    int i = 1;
    String last = "";
    while (this.isNumerical(Character.valueOf(time.charAt((time.length() - i))).toString())) {
      int _length = time.length();
      boolean _lessThan = (i < _length);
      if (_lessThan) {
        i++;
      } else {
        return time;
      }
    }
    for (i--; (i > 0); i--) {
      String _last = last;
      int _length = time.length();
      int _minus = (_length - i);
      String _string = Character.valueOf(time.charAt(_minus)).toString();
      last = (_last + _string);
    }
    return last;
  }
  
  public boolean isNumerical(final String _char) {
    boolean _xifexpression = false;
    boolean _equals = _char.toUpperCase().equals(_char.toLowerCase());
    if (_equals) {
      _xifexpression = true;
    } else {
      _xifexpression = false;
    }
    return _xifexpression;
  }
  
  public String fraction(final String value) {
    int _length = value.length();
    boolean _equals = (_length == 3);
    if (_equals) {
      return value;
    }
    int _length_1 = value.length();
    boolean _equals_1 = (_length_1 == 2);
    if (_equals_1) {
      return ("0" + value);
    }
    int _length_2 = value.length();
    boolean _equals_2 = (_length_2 == 1);
    if (_equals_2) {
      return ("00" + value);
    }
    int _length_3 = value.length();
    boolean _equals_3 = (_length_3 == 0);
    if (_equals_3) {
      return "000";
    }
    return null;
  }
  
  private void checkUnderscoreNotation(final String string, final EObject object, final EReference reference) {
    int _length = string.length();
    int _minus = (_length - 1);
    final char lastChar = string.charAt(_minus);
    boolean _equals = Character.valueOf(lastChar).toString().equals("_");
    if (_equals) {
      this.error("Invalid underscore notation.", object, reference, EisValidator.INVALID_UNDERSCORE_NOTATION);
    }
  }
  
  private boolean checkNumericalValues(final long idiom, final DefineType expectedType) {
    boolean _switchResult = false;
    boolean _matched = false;
    boolean _isUSIntType = this._defineTypeComputer.isUSIntType(expectedType);
    if (_isUSIntType) {
      _matched=true;
      _switchResult = this.isOutOfNumericalBounds(idiom, 0, 255);
    }
    if (!_matched) {
      boolean _isUIntType = this._defineTypeComputer.isUIntType(expectedType);
      if (_isUIntType) {
        _matched=true;
        _switchResult = this.isOutOfNumericalBounds(idiom, 0, 65535);
      }
    }
    if (!_matched) {
      boolean _isUDIntType = this._defineTypeComputer.isUDIntType(expectedType);
      if (_isUDIntType) {
        _matched=true;
        _switchResult = this.isOutOfNumericalBounds(idiom, 0, 4294967295L);
      }
    }
    if (!_matched) {
      boolean _isULIntType = this._defineTypeComputer.isULIntType(expectedType);
      if (_isULIntType) {
        _matched=true;
        boolean _xifexpression = false;
        int _intValue = Long.valueOf(idiom).intValue();
        boolean _lessThan = (_intValue < 0);
        if (_lessThan) {
          _xifexpression = true;
        } else {
          _xifexpression = false;
        }
        _switchResult = _xifexpression;
      }
    }
    if (!_matched) {
      boolean _isSIntType = this._defineTypeComputer.isSIntType(expectedType);
      if (_isSIntType) {
        _matched=true;
        _switchResult = this.isOutOfNumericalBounds(idiom, (-128), 127);
      }
    }
    if (!_matched) {
      boolean _isIntType = this._defineTypeComputer.isIntType(expectedType);
      if (_isIntType) {
        _matched=true;
        _switchResult = this.isOutOfNumericalBounds(idiom, (-32768), 32767);
      }
    }
    if (!_matched) {
      boolean _isDIntType = this._defineTypeComputer.isDIntType(expectedType);
      if (_isDIntType) {
        _matched=true;
        _switchResult = this.isOutOfNumericalBounds(idiom, (-2147483647), 2147483647);
      }
    }
    if (!_matched) {
      _switchResult = false;
    }
    return _switchResult;
  }
  
  private boolean isOutOfNumericalBounds(final long idiom, final int lower, final long upper) {
    boolean outOfBounds = false;
    if (((idiom < lower) || (idiom > upper))) {
      outOfBounds = true;
    }
    return outOfBounds;
  }
  
  private EObject directionBlock(final EObject context) {
    EObject _xblockexpression = null;
    {
      final EObject container = context.eContainer();
      EObject _xifexpression = null;
      if ((container instanceof DirectionBlock)) {
        return context;
      } else {
        _xifexpression = this.directionBlock(container);
      }
      _xblockexpression = _xifexpression;
    }
    return _xblockexpression;
  }
  
  private void checkVariableTypeAndAddToMap(final Variables e, final HashMultimap<String, Variables> multiMap) {
    if ((e instanceof Udt)) {
      multiMap.put(((Udt)e).getName(), e);
    } else {
      if ((e instanceof Variable)) {
        multiMap.put(((Variable)e).getName(), e);
      }
    }
  }
  
  private void checkAllVariableNamesInUdtScope(final Udt udt) {
    final HashMultimap<String, Variables> newMultimap = HashMultimap.<String, Variables>create();
    final EList<Variables> udts = udt.getUdtVariables();
    for (final Variables e : udts) {
      {
        this.checkVariableTypeAndAddToMap(e, newMultimap);
        if ((e instanceof Udt)) {
          this.checkAllVariableNamesInUdtScope(((Udt)e));
        }
      }
    }
    Set<Map.Entry<String, Collection<Variables>>> _entrySet = newMultimap.asMap().entrySet();
    for (final Map.Entry<String, Collection<Variables>> entry : _entrySet) {
      {
        final Collection<Variables> duplicates = entry.getValue();
        int _size = duplicates.size();
        boolean _greaterThan = (_size > 1);
        if (_greaterThan) {
          for (final Variables d : duplicates) {
            this.checkVariableTypeAndCallError(d);
          }
        }
      }
    }
  }
  
  private void checkVariableTypeAndCallError(final Variables e) {
    if ((e instanceof Udt)) {
      String _name = ((Udt)e).getName();
      String _plus = ("Multiple variable name \'" + _name);
      String _plus_1 = (_plus + "\'");
      this.error(_plus_1, e, EisPackage.eINSTANCE.getVariables_Name(), 
        EisValidator.MULTIPLE_UDT_DECLARATION);
    } else {
      if ((e instanceof Variable)) {
        String _name_1 = ((Variable)e).getName();
        String _plus_2 = ("Multiple variable name \'" + _name_1);
        String _plus_3 = (_plus_2 + "\'");
        this.error(_plus_3, e, EisPackage.eINSTANCE.getVariables_Name(), 
          EisValidator.MULTIPLE_VARIABLE_DECLARATION);
      }
    }
  }
  
  private void checkNoDuplicateUdtTypes(final Udt udt) {
    HashMultimap<String, Udt> multiMap = HashMultimap.<String, Udt>create();
    final EList<Variables> udts = udt.getUdtVariables();
    for (final Variables e : udts) {
      if ((e instanceof Udt)) {
        multiMap.put(((Udt)e).getUdtType().getName(), ((Udt)e));
        this.checkNoDuplicateUdtTypes(((Udt)e));
      }
    }
  }
  
  private void checkExpectedBoolean(final Idiom exp, final EReference reference) {
    this.checkExpectedType(exp, DefineTypeComputer.BOOL_TYPE, reference);
  }
  
  private void checkExpectedInt(final Idiom exp, final EReference reference) {
    this.checkExpectedType(exp, DefineTypeComputer.INT_TYPE, reference);
  }
  
  private void checkExpectedDouble(final Idiom exp, final EReference reference) {
    this.checkExpectedType(exp, DefineTypeComputer.REAL_TYPE, reference);
  }
  
  private void checkExpectedType(final Idiom exp, final DefineType expectedType, final EReference reference) {
    final DefineType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(((("expected " + expectedType) + " type, but was ") + actualType), reference, EisValidator.TYPE_MISMATCH);
    }
  }
  
  private DefineType getTypeAndCheckNotNull(final Idiom exp, final EReference reference) {
    DefineType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._defineTypeComputer.typeFor(exp);
    }
    DefineType type = _typeFor;
    if ((type == null)) {
      this.error("null type", reference, EisValidator.TYPE_MISMATCH);
    }
    return type;
  }
  
  private void checkExpectedSameType(final DefineType left, final DefineType right) {
    if ((((right != null) && (left != null)) && (!Objects.equal(right, left)))) {
      this.error(((("expected the same type, but was " + left) + ", ") + right), EisPackage.Literals.EQUALITY.getEIDAttribute(), 
        EisValidator.TYPE_MISMATCH);
    }
  }
  
  private void checkNotBoolean(final DefineType type, final EReference reference) {
    boolean _isBoolType = this._defineTypeComputer.isBoolType(type);
    if (_isBoolType) {
      this.error("cannot be boolean", reference, EisValidator.TYPE_MISMATCH);
    }
  }
  
  private void compareTypesAndCallErrorOnMismatch(final Statement statement, final DefineType actualType, final BasicType _expectedType, final DefineType rangeType) {
    final DefineType expectedType = this._defineTypeComputer.typeFor(_expectedType);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      boolean _not = (!(this._defineTypeComputer.isIntSuperType(actualType) && this._defineTypeComputer.isIntSuperType(expectedType)));
      if (_not) {
        String _string = expectedType.toString();
        String _plus = ("Incompatible types. Expected \'" + _string);
        String _plus_1 = (_plus + "\' but was \'");
        String _string_1 = actualType.toString();
        String _plus_2 = (_plus_1 + _string_1);
        String _plus_3 = (_plus_2 + 
          "\'");
        this.error(_plus_3, statement, EisPackage.eINSTANCE.getStatement_Idiom(), EisValidator.INCOMPATIBLE_TYPES);
      }
    }
    if (((rangeType != null) && (!Objects.equal(rangeType, expectedType)))) {
      boolean _not_1 = (!(this._defineTypeComputer.isIntSuperType(rangeType) && this._defineTypeComputer.isIntSuperType(expectedType)));
      if (_not_1) {
        String _string_2 = expectedType.toString();
        String _plus_4 = ("Incompatible types. Expected \'" + _string_2);
        String _plus_5 = (_plus_4 + "\' but was \'");
        String _string_3 = rangeType.toString();
        String _plus_6 = (_plus_5 + _string_3);
        String _plus_7 = (_plus_6 + 
          "\'");
        this.error(_plus_7, statement, EisPackage.eINSTANCE.getStatement_Range(), EisValidator.INCOMPATIBLE_TYPES);
      }
    }
  }
  
  private void checkCommaSyntaxWithVariables(final Iterable<? extends Variables> variables) {
    int count = 0;
    int countOfVariableBefore = 0;
    boolean commaBeforeVariable = false;
    BasicType helpingVariableType = BasicType.NULL;
    boolean variantKeyword = false;
    boolean inoutKeyword = false;
    for (final Variables e : variables) {
      {
        if ((e instanceof Udt)) {
          boolean _isEmpty = ((Udt)e).getUdtVariables().isEmpty();
          boolean _not = (!_isEmpty);
          if (_not) {
            this.checkCommaSyntaxWithVariables(((Udt)e).getUdtVariables());
          }
        }
        if ((commaBeforeVariable && (!(e instanceof Variable)))) {
          this.error("Invalid comma. Semicolon expected.", ((EObject[])Conversions.unwrapArray(variables, EObject.class))[countOfVariableBefore], 
            EisPackage.eINSTANCE.getVariable_NextVariable(), EisValidator.INVALID_COMMA_NOTATION);
        }
        if ((e instanceof Variable)) {
          if (((count - countOfVariableBefore) > 1)) {
            commaBeforeVariable = false;
          }
          if ((!commaBeforeVariable)) {
            BasicType _variableType = ((Variable)e).getVariableType();
            boolean _tripleEquals = (_variableType == BasicType.NULL);
            if (_tripleEquals) {
              this.error("Missing variable type", e, EisPackage.eINSTANCE.getVariable_VariableType(), 
                EisValidator.MISSING_VARIABLE_TYPE);
            }
          } else {
            BasicType _variableType_1 = ((Variable)e).getVariableType();
            boolean _tripleEquals_1 = (_variableType_1 == BasicType.NULL);
            if (_tripleEquals_1) {
              ((Variable)e).setVariableType(helpingVariableType);
            } else {
              BasicType _variableType_2 = ((Variable)e).getVariableType();
              boolean _tripleNotEquals = (helpingVariableType != _variableType_2);
              if (_tripleNotEquals) {
                this.error("Multiple type definition", e, EisPackage.eINSTANCE.getVariable_VariableType(), 
                  EisValidator.MULTIPLE_TYPE_DEFINITION);
              }
            }
            if ((((Variable)e).isVariantKeyword() && (!variantKeyword))) {
              this.error("Invalid variant keyword", e, EisPackage.eINSTANCE.getVariable_VariantKeyword(), 
                EisValidator.INVALID_VARIANT_KEYWORD);
            } else {
              ((Variable)e).setVariantKeyword(variantKeyword);
            }
            if ((((Variable)e).isInout() && (!inoutKeyword))) {
              this.error("Invalid inout keyword", e, EisPackage.eINSTANCE.getVariables_Inout(), EisValidator.INVALID_INOUT_KEYWORD);
            } else {
              ((Variable)e).setInout(inoutKeyword);
            }
          }
          boolean _isNextVariable = ((Variable)e).isNextVariable();
          if (_isNextVariable) {
            commaBeforeVariable = true;
            countOfVariableBefore = count;
            helpingVariableType = ((Variable)e).getVariableType();
          } else {
            commaBeforeVariable = false;
            helpingVariableType = null;
          }
          variantKeyword = ((Variable)e).isVariantKeyword();
          inoutKeyword = ((Variable)e).isInout();
        }
        count++;
      }
    }
    final Variables last = IterableExtensions.last(variables);
    if ((last instanceof Variable)) {
      boolean _isNextVariable = ((Variable)last).isNextVariable();
      if (_isNextVariable) {
        this.error("Invalid comma. Semicolon expected.", last, EisPackage.eINSTANCE.getVariable_NextVariable(), 
          EisValidator.INVALID_COMMA_NOTATION);
      }
    }
  }
  
  private Variable assignNewVariable(final Iterable<? extends Variables> referredUdtVars, final int count, final boolean inout) {
    VariableImpl newVariable = new VariableImpl();
    Variables _get = ((Variables[])Conversions.unwrapArray(referredUdtVars, Variables.class))[count];
    final Variable variable = ((Variable) _get);
    newVariable.setName(variable.getName());
    newVariable.setVariableType(variable.getVariableType());
    newVariable.setVariantKeyword(variable.isVariantKeyword());
    newVariable.setNextVariable(variable.isNextVariable());
    if (inout) {
      newVariable.setInout(true);
    } else {
      newVariable.setInout(variable.isInout());
    }
    if (((variable.getIdiom() instanceof VariableRef) || (variable.getRange() instanceof VariableRef))) {
      this.error("This reference cannot be made because a variable contains other references ", 
        EisPackage.eINSTANCE.getUdtRef_UdtType(), EisValidator.RECURSIVE_VARIABLE_REFERENCE);
    } else {
      final DefineType type = this._defineTypeComputer.typeFor(newVariable.getVariableType());
      Idiom _idiom = null;
      if (variable!=null) {
        _idiom=variable.getIdiom();
      }
      boolean _tripleNotEquals = (_idiom != null);
      if (_tripleNotEquals) {
        boolean _matched = false;
        boolean _isStringType = this._defineTypeComputer.isStringType(type);
        if (_isStringType) {
          _matched=true;
          StringConstantImpl _stringConstantImpl = new StringConstantImpl();
          newVariable.setIdiom(_stringConstantImpl);
          Idiom _idiom_1 = newVariable.getIdiom();
          Idiom _idiom_2 = null;
          if (variable!=null) {
            _idiom_2=variable.getIdiom();
          }
          Object _interpret = null;
          if (_idiom_2!=null) {
            _interpret=this._eisInterpreter.interpret(_idiom_2);
          }
          String _string = null;
          if (_interpret!=null) {
            _string=_interpret.toString();
          }
          ((StringConstant) _idiom_1).setValue(_string);
        }
        if (!_matched) {
          boolean _isBoolType = this._defineTypeComputer.isBoolType(type);
          if (_isBoolType) {
            _matched=true;
            BoolConstantImpl _boolConstantImpl = new BoolConstantImpl();
            newVariable.setIdiom(_boolConstantImpl);
            Idiom _idiom_3 = newVariable.getIdiom();
            Idiom _idiom_4 = null;
            if (variable!=null) {
              _idiom_4=variable.getIdiom();
            }
            Object _interpret_1 = null;
            if (_idiom_4!=null) {
              _interpret_1=this._eisInterpreter.interpret(_idiom_4);
            }
            String _string_1 = null;
            if (_interpret_1!=null) {
              _string_1=_interpret_1.toString();
            }
            ((BoolConstant) _idiom_3).setValue(_string_1);
          }
        }
        if (!_matched) {
          boolean _isIntSuperType = this._defineTypeComputer.isIntSuperType(type);
          if (_isIntSuperType) {
            _matched=true;
            IntConstantImpl _intConstantImpl = new IntConstantImpl();
            newVariable.setIdiom(_intConstantImpl);
            Idiom _idiom_5 = newVariable.getIdiom();
            Idiom _idiom_6 = null;
            if (variable!=null) {
              _idiom_6=variable.getIdiom();
            }
            Object _interpret_2 = null;
            if (_idiom_6!=null) {
              _interpret_2=this._eisInterpreter.interpret(_idiom_6);
            }
            ((IntConstant) _idiom_5).setValue((((Long) _interpret_2)).longValue());
          }
        }
      }
      Idiom _range = null;
      if (variable!=null) {
        _range=variable.getRange();
      }
      boolean _tripleNotEquals_1 = (_range != null);
      if (_tripleNotEquals_1) {
        boolean _matched_1 = false;
        boolean _isStringType_1 = this._defineTypeComputer.isStringType(type);
        if (_isStringType_1) {
          _matched_1=true;
          StringConstantImpl _stringConstantImpl_1 = new StringConstantImpl();
          newVariable.setRange(_stringConstantImpl_1);
          Idiom _range_1 = newVariable.getRange();
          Idiom _range_2 = null;
          if (variable!=null) {
            _range_2=variable.getRange();
          }
          Object _interpret_3 = null;
          if (_range_2!=null) {
            _interpret_3=this._eisInterpreter.interpret(_range_2);
          }
          String _string_2 = null;
          if (_interpret_3!=null) {
            _string_2=_interpret_3.toString();
          }
          ((StringConstant) _range_1).setValue(_string_2);
        }
        if (!_matched_1) {
          boolean _isBoolType_1 = this._defineTypeComputer.isBoolType(type);
          if (_isBoolType_1) {
            _matched_1=true;
            BoolConstantImpl _boolConstantImpl_1 = new BoolConstantImpl();
            newVariable.setRange(_boolConstantImpl_1);
            Idiom _range_3 = newVariable.getRange();
            Idiom _range_4 = null;
            if (variable!=null) {
              _range_4=variable.getRange();
            }
            Object _interpret_4 = null;
            if (_range_4!=null) {
              _interpret_4=this._eisInterpreter.interpret(_range_4);
            }
            String _string_3 = null;
            if (_interpret_4!=null) {
              _string_3=_interpret_4.toString();
            }
            ((BoolConstant) _range_3).setValue(_string_3);
          }
        }
        if (!_matched_1) {
          boolean _isIntSuperType_1 = this._defineTypeComputer.isIntSuperType(type);
          if (_isIntSuperType_1) {
            _matched_1=true;
            IntConstantImpl _intConstantImpl_1 = new IntConstantImpl();
            newVariable.setRange(_intConstantImpl_1);
            Idiom _range_5 = newVariable.getRange();
            Idiom _range_6 = null;
            if (variable!=null) {
              _range_6=variable.getRange();
            }
            Object _interpret_5 = null;
            if (_range_6!=null) {
              _interpret_5=this._eisInterpreter.interpret(_range_6);
            }
            ((IntConstant) _range_5).setValue((((Long) _interpret_5)).longValue());
          }
        }
      }
    }
    return newVariable;
  }
  
  private Udt assignNewUdt(final Iterable<? extends Variables> referredUdtVars, final int count, final boolean inout) {
    UdtImpl newUdt = new UdtImpl();
    Variables _get = ((Variables[])Conversions.unwrapArray(referredUdtVars, Variables.class))[count];
    final Udt childRef = ((Udt) _get);
    final EList<Variables> childRefVars = childRef.getUdtVariables();
    int count2 = 0;
    newUdt.setName(childRef.getName());
    newUdt.setUdtType(childRef.getUdtType());
    if (inout) {
      newUdt.setInout(true);
    } else {
      newUdt.setInout(childRef.isInout());
    }
    boolean _isEmpty = childRefVars.isEmpty();
    boolean _not = (!_isEmpty);
    if (_not) {
      for (final Variables e : childRefVars) {
        {
          if ((e instanceof Variable)) {
            newUdt.getUdtVariables().add(this.assignNewVariable(childRefVars, count2, inout));
          } else {
            if ((e instanceof Udt)) {
              newUdt.getUdtVariables().add(this.assignNewUdt(childRefVars, count2, inout));
            } else {
              if ((e instanceof UdtRef)) {
                this.error("This reference cannot be made because the udt itself contains other references ", ((UdtRef) e), EisPackage.eINSTANCE.getUdtRef_UdtType(), EisValidator.RECURSIVE_UDT_REFERENCE);
              }
            }
          }
          count2++;
        }
      }
    }
    return newUdt;
  }
  
  @Check
  public void checkUppercaseVariantName() {
  }
  
  @Check
  public void checkUppercaseUdtName() {
  }
  
  @Check
  public void checkLowercaseUdtType() {
  }
}
