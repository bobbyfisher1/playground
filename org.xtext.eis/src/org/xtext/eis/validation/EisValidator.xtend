/*
 * generated by Xtext 2.14.0
 */
package org.xtext.eis.validation

import com.google.common.collect.HashMultimap
import com.google.inject.Inject
import java.time.Duration
import java.time.LocalDate
import java.time.format.DateTimeFormatter
import java.time.format.DateTimeParseException
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.xtext.validation.Check
import org.xtext.eis.eis.And
import org.xtext.eis.eis.Assert
import org.xtext.eis.eis.BasicType
import org.xtext.eis.eis.BoolConstant
import org.xtext.eis.eis.Comparison
import org.xtext.eis.eis.DefineBlock
import org.xtext.eis.eis.DirectionBlock
import org.xtext.eis.eis.EisModel
import org.xtext.eis.eis.EisPackage
import org.xtext.eis.eis.Equality
import org.xtext.eis.eis.Idiom
import org.xtext.eis.eis.InOut
import org.xtext.eis.eis.Input
import org.xtext.eis.eis.IntConstant
import org.xtext.eis.eis.Minus
import org.xtext.eis.eis.MulOrDiv
import org.xtext.eis.eis.Not
import org.xtext.eis.eis.Or
import org.xtext.eis.eis.Plus
import org.xtext.eis.eis.Set
import org.xtext.eis.eis.Statement
import org.xtext.eis.eis.StringConstant
import org.xtext.eis.eis.Udt
import org.xtext.eis.eis.UdtRef
import org.xtext.eis.eis.Variable
import org.xtext.eis.eis.VariableRef
import org.xtext.eis.eis.Variables
import org.xtext.eis.eis.impl.BoolConstantImpl
import org.xtext.eis.eis.impl.IntConstantImpl
import org.xtext.eis.eis.impl.StringConstantImpl
import org.xtext.eis.eis.impl.UdtImpl
import org.xtext.eis.eis.impl.VariableImpl
import org.xtext.eis.interpreter.EisInterpreter
import org.xtext.eis.typing.DefineType
import org.xtext.eis.typing.DefineTypeComputer
import org.xtext.eis.typing.types.DateType
import org.xtext.eis.typing.types.LTimeType
import org.xtext.eis.typing.types.RealType
import org.xtext.eis.typing.types.TimeType

class EisValidator extends AbstractEisValidator {

	protected static val ISSUE_CODE_PREFIX = "org.example.entities.";
	public static val MULTIPLE_VARIABLE_DECLARATION = ISSUE_CODE_PREFIX + "MultipleVariableDeclaration"
	public static val MULTIPLE_UDT_DECLARATION = ISSUE_CODE_PREFIX + "MultipleUdtDeclaration"
	public static val MISSING_VARIABLE_TYPE = ISSUE_CODE_PREFIX + "MissingVariableType"
	public static val MULTIPLE_TYPE_DEFINITION = ISSUE_CODE_PREFIX + "MultipleTypeDefinition"
	public static val INVALID_VARIANT_KEYWORD = ISSUE_CODE_PREFIX + "InvalidVariantKeyword"
//	public static val INVALID_INOUT_KEYWORD = ISSUE_CODE_PREFIX + "InvalidInOutKeyword"
	public static val INVALID_COMMA_NOTATION = ISSUE_CODE_PREFIX + "InvalidCommaNotation"
	public static val TYPE_MISMATCH = ISSUE_CODE_PREFIX + "TypeMismatch"
	public static val INCOMPATIBLE_TYPES = ISSUE_CODE_PREFIX + "IncompatibleTypes"
	public static val NULL_REFERENCE = ISSUE_CODE_PREFIX + "NullReference"
	public static val MULTIPLE_UDT_TYPE = ISSUE_CODE_PREFIX + "MultipleUdtType"
	public static val VARIANT_MISMATCH = ISSUE_CODE_PREFIX + "VariantMismatch"
	public static val RECURSIVE_VARIABLE_REFERENCE = ISSUE_CODE_PREFIX + "RecursiveVariableReference"
	public static val RECURSIVE_UDT_REFERENCE = ISSUE_CODE_PREFIX + "RecursiveUdtReference"
	public static val MULTIPLE_STATEMENT_ASSIGNMENT = ISSUE_CODE_PREFIX + "MultipleStatementAssignment"
	public static val MISSING_UDT_REFERENCE = ISSUE_CODE_PREFIX + "MissingUdtReference"
	public static val INVALID_RANGE_DEFINITION = ISSUE_CODE_PREFIX + "InvalidRangeDefinition"
	public static val MULTIPLE_PLCCYCLE = ISSUE_CODE_PREFIX + "MultiplePlcCycle"
	public static val MULTIPLE_TESTCASE_NAME = ISSUE_CODE_PREFIX + "MultipleTestcaseName"
	public static val VALUE_EXCEEDING_DATATYPE_BOUNDS = ISSUE_CODE_PREFIX + "ValueExceedingDatatypeBounds"
	public static val DIVISION_BY_ZERO = ISSUE_CODE_PREFIX + "DivisionByZero"
	public static val NEGATIVE_PLCCYCLE = ISSUE_CODE_PREFIX + "NegativePlcCycle"
	public static val INVALID_UNDERSCORE_NOTATION = ISSUE_CODE_PREFIX + "InvalidUnderscoreNotation"
	public static val INVALID_DATE_NOTATION = ISSUE_CODE_PREFIX + "InvalidDateNotation"

	@Inject extension DefineTypeComputer
	@Inject extension EisInterpreter

//
// checks -----------------------------------------------------------------------------------------------------------------------------------------------------------------
//
	@Check def void checkNoDuplicateVariablesIO(DirectionBlock directionblock) {
		val in = directionblock.input.inputVariables
		val out = directionblock.output.outputVariables
		val multiMap = HashMultimap.create()

		// add all variables to the map
		for (e : in) {
			e.checkVariableTypeAndAddToMap(multiMap)
			if (e instanceof Udt)
				e.checkAllVariableNamesInUdtScope
		}

		for (e : out) {
			e.checkVariableTypeAndAddToMap(multiMap)
			if (e instanceof Udt)
				e.checkAllVariableNamesInUdtScope
		}

		// check for duplicates
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					d.checkVariableTypeAndCallError
			}
		}
	}

	@Check def void checkNoDuplicateVariablesIOInOut(DirectionBlock directionblock) {
		val in = directionblock.input.inputVariables
		val out = directionblock.output.outputVariables
		val inout = directionblock.inout.inoutVariables
		val multiMap = HashMultimap.create

		// add all variables to the multimap
		for (e : in) {
			e.checkVariableTypeAndAddToMap(multiMap)
			if (e instanceof Udt)
				e.checkAllVariableNamesInUdtScope
		}
		for (e : out) {
			e.checkVariableTypeAndAddToMap(multiMap)
			if (e instanceof Udt)
				e.checkAllVariableNamesInUdtScope
		}

		for (e : inout) {
			e.checkVariableTypeAndAddToMap(multiMap)
			if (e instanceof Udt)
				e.checkAllVariableNamesInUdtScope
		}

		// check for duplicates
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					d.checkVariableTypeAndCallError
			}
		}
	}

	@Check def void checkNoDuplicateUdtTypesIO(DirectionBlock directionblock) {
		var multiMap = HashMultimap.create
		val in = directionblock.input.inputVariables
		val out = directionblock.output.outputVariables

		// add all udtTypes of input to the multimap
		for (e : in) {
			if (e instanceof Udt) {
				multiMap.put(e.udtType.name, e)
				e.checkNoDuplicateUdtTypes
			}
		}

		for (e : out) {
			if (e instanceof Udt) {
				multiMap.put(e.udtType.name, e)
				e.checkNoDuplicateUdtTypes
			}
		}
		// check for duplicates
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					error("Multiple udtType '" + (d as Udt).udtType.name + "'", d, EisPackage.eINSTANCE.udt_UdtType,
						EisValidator.MULTIPLE_UDT_TYPE)
			}
		}
	}

	@Check def void checkNoDuplicateUdtTypesIOInOut(DirectionBlock directionblock) {
		var multiMap = HashMultimap.create
		val in = directionblock.input.inputVariables
		val out = directionblock.output.outputVariables
		val inout = directionblock.inout.inoutVariables

		// add all udtTypes of input to the multimap
		for (e : in) {
			if (e instanceof Udt) {
				multiMap.put(e.udtType.name, e)
				e.checkNoDuplicateUdtTypes
			}
		}

		for (e : out) {
			if (e instanceof Udt) {
				multiMap.put(e.udtType.name, e)
				e.checkNoDuplicateUdtTypes
			}
		}
		for (e : inout) {
			if (e instanceof Udt) {
				multiMap.put(e.udtType.name, e)
				e.checkNoDuplicateUdtTypes
			}
		}
		// check for duplicates
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					error("Multiple udtType '" + (d as Udt).udtType.name + "'", d, EisPackage.eINSTANCE.udt_UdtType,
						EisValidator.MULTIPLE_UDT_TYPE)
			}
		}
	}

	@Check def void checkType(Not not) {
		checkExpectedBoolean(not.idiom, EisPackage.Literals.NOT__IDIOM)
	}

	@Check def void checkType(And and) {
		checkExpectedBoolean(and.left, EisPackage.Literals.AND__LEFT)
		checkExpectedBoolean(and.right, EisPackage.Literals.AND__RIGHT)
	}

	@Check def void checkType(Or or) {
		checkExpectedBoolean(or.left, EisPackage.Literals.OR__LEFT)
		checkExpectedBoolean(or.right, EisPackage.Literals.OR__RIGHT)
	}

	@Check def void checkType(Minus minus) {
		val left = minus.left.interpret
		val right = minus.right.interpret

		if (left instanceof Double || right instanceof Double) {
			checkExpectedDouble(minus.left, EisPackage.Literals.MINUS__LEFT)
			checkExpectedDouble(minus.right, EisPackage.Literals.MINUS__RIGHT)
		} else {
			checkExpectedInt(minus.left, EisPackage.Literals.MINUS__LEFT)
			checkExpectedInt(minus.right, EisPackage.Literals.MINUS__RIGHT)
		}

	}

	@Check def void checkType(MulOrDiv mulOrDiv) {
		val left = mulOrDiv.left.interpret
		val right = mulOrDiv.right.interpret

		if (left instanceof Double || right instanceof Double) {
			checkExpectedDouble(mulOrDiv.right, EisPackage.Literals.MUL_OR_DIV__LEFT)
			checkExpectedDouble(mulOrDiv.right, EisPackage.Literals.MUL_OR_DIV__RIGHT)
		} else {
			checkExpectedInt(mulOrDiv.left, EisPackage.Literals.MUL_OR_DIV__LEFT)
			checkExpectedInt(mulOrDiv.right, EisPackage.Literals.MUL_OR_DIV__RIGHT)
		}
	}

	@Check def void checkDivisionByZero(MulOrDiv mulOrDiv) {
		val right = mulOrDiv.right.interpret
		if (right instanceof Long)
			if (right == 0)
				error("Division by zero.", mulOrDiv, EisPackage.eINSTANCE.mulOrDiv_Right, DIVISION_BY_ZERO)
		if (right instanceof Double)
			if (!(right < 0) && !(right > 0))
				error("Division by zero.", mulOrDiv, EisPackage.eINSTANCE.mulOrDiv_Right, DIVISION_BY_ZERO)

	}

	@Check def void checkType(Equality equality) {
		val leftType = getTypeAndCheckNotNull(equality.left, EisPackage.Literals.EQUALITY__LEFT)
		val rightType = getTypeAndCheckNotNull(equality.right, EisPackage.Literals.EQUALITY__RIGHT)
		checkExpectedSameType(leftType, rightType)
	}

	@Check def void checkType(Comparison comparison) {
		val leftType = getTypeAndCheckNotNull(comparison.left, EisPackage.Literals.COMPARISON__LEFT)
		val rightType = getTypeAndCheckNotNull(comparison.right, EisPackage.Literals.COMPARISON__RIGHT)
		checkExpectedSameType(leftType, rightType)
		checkNotBoolean(leftType, EisPackage.Literals.COMPARISON__LEFT)
		checkNotBoolean(rightType, EisPackage.Literals.COMPARISON__RIGHT)
	}

	@Check def void checkType(Plus plus) {
		val leftType = getTypeAndCheckNotNull(plus.left, EisPackage.Literals.PLUS__LEFT)
		val rightType = getTypeAndCheckNotNull(plus.right, EisPackage.Literals.PLUS__RIGHT)
		if (leftType.isIntSuperType || rightType.isIntSuperType ||
			(!leftType.isStringType && !rightType.isStringType)) {
			checkNotBoolean(leftType, EisPackage.Literals.PLUS__LEFT)
			checkNotBoolean(rightType, EisPackage.Literals.PLUS__RIGHT)
		}
	}

	@Check def void checkType(Variable variable) {
		if (variable.idiom !== null) {
			val expectedType = variable.variableType.typeFor
			val actualType = variable?.idiom.typeFor
			val rangeType = variable?.range?.typeFor

			if (expectedType === null || actualType === null)
				return;

			if (expectedType !== actualType)
				if (!(actualType.isIntSuperType && expectedType.isIntSuperType ))
					error(
						"Incompatible types. Expected '" + expectedType.toString + "' but was '" + actualType.toString +
							"'", variable, EisPackage.eINSTANCE.variable_Idiom, INCOMPATIBLE_TYPES)

			if (rangeType !== null && rangeType != expectedType)
				if (!(rangeType.isIntSuperType && expectedType.isIntSuperType ))
					error(
						"Incompatible types. Expected '" + expectedType.toString + "' but was '" + rangeType.toString +
							"'", variable, EisPackage.eINSTANCE.variable_Range, INCOMPATIBLE_TYPES)

		}
	}

	@Check def void checkRangesOnStatements(Statement statement) {
		val cascade = statement.cascade
		val variable = statement.variable
		val last = cascade?.last?.udtVar

		val actualType = statement.idiom.typeFor
		val rangeType = statement?.range?.typeFor
		var expectedType = BasicType.NULL

		if (variable instanceof Variable) {
			expectedType = (variable as Variable).variableType
			compareTypesAndCallErrorOnMismatch(statement, actualType, expectedType, rangeType)
			if (rangeType !== null) {
				if (expectedType.typeFor.isWithoutRangeOp)
					error("The range feature is not permitted to this type", statement,
						EisPackage.eINSTANCE.statement_Range, INVALID_RANGE_DEFINITION)

			}
		} else if (last instanceof Variable) {
			expectedType = last.variableType
			compareTypesAndCallErrorOnMismatch(statement, actualType, expectedType, rangeType)
			if (rangeType !== null) {
				if (expectedType.typeFor.isWithoutRangeOp)
					error("The range feature is not permitted to this type", statement,
						EisPackage.eINSTANCE.statement_Range, INVALID_RANGE_DEFINITION)
			}
		}
	}

	@Check def void checkCommaSyntaxIO(DirectionBlock directionblock) {
		val in = directionblock.input.inputVariables
		val out = directionblock.output.outputVariables
		if (!in.empty) {
			checkCommaSyntaxWithVariables(in)
		}
		if (!out.empty) {
			checkCommaSyntaxWithVariables(out)
		}
	}

	@Check def void checkCommaSyntaxIOInOut(InOut inouts) {
		val inout = inouts.inoutVariables
		if (!inout.empty) {
			checkCommaSyntaxWithVariables(inout)
		}
	}

	@Check def void checkNullVariableRefs(VariableRef varRef) {
		if (varRef.variable.idiom === null)
			error("Referred variable '" + varRef.variable.name + "' is null.", varRef,
				EisPackage.eINSTANCE.variableRef_Variable, NULL_REFERENCE)
	}

	@Check def void checkVariantWithRefs(VariableRef varRef) {
		val variable = varRef.eContainer
		if ((variable as Variable).variantKeyword !== varRef.variable.variantKeyword)
			error("Both variables must be variant types.", variable, EisPackage.eINSTANCE.variable_VariantKeyword,
				VARIANT_MISMATCH)
	}

	@Check def void checkUdtRefs(UdtRef udtRef) {
		var ownUdtVars = udtRef.udtVariables
		val referredUdtVars = (udtRef.udtType.eContainer as Udt).udtVariables
		var count = 0

		ownUdtVars.clear
		if (!referredUdtVars.empty) {
			for (e : referredUdtVars) {
				if (e instanceof Variable) {
					ownUdtVars.add(assignNewVariable(referredUdtVars, count))
				} else if (e instanceof Udt) {
					ownUdtVars.add(assignNewUdt(referredUdtVars, count))
				} else if (e instanceof UdtRef) {
					error("This reference cannot be made because the udt itself contains other references ", udtRef,
						EisPackage.eINSTANCE.udtRef_UdtType, RECURSIVE_UDT_REFERENCE)
				}
				count++
			}
		}
	}

	@Check def void checkUdtStatements(Statement statement) {
		if (!(statement.variable instanceof Variable) && statement.cascade.empty) {
			error("Only variables can be assigned to values", statement, EisPackage.eINSTANCE.statement_Variable,
				MISSING_UDT_REFERENCE)
		}

		val cascade = statement.cascade

		for (c : cascade) {
			if (!(c.udtVar instanceof Variable) && c === cascade.last) {
				error("Only variables can be assigned to values", statement, EisPackage.eINSTANCE.statement_Cascade,
					MISSING_UDT_REFERENCE)
			}
		}
	}

	@Check def void checkMultipleStatementsSetBlock(Set sets) {
		val set = sets.setVariables
		val multiMap = HashMultimap.create()
		var name = set?.head?.variable?.toString

		// add all variables to the map
		for (e : set) {
			if (e.cascade.empty)
				multiMap.put(e.variable, e)
			else {
				name = e.variable.toString
				for (c : e.cascade)
					name += c.udtVar.toString
				multiMap.put(name, e)
			}
		}

		// check for duplicates
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates) {
					if (d.cascade.empty)
						error("Multiple variable assignment", d, EisPackage.eINSTANCE.statement_Variable,
							MULTIPLE_STATEMENT_ASSIGNMENT)
					else {
						error("Multiple variable assignment", d, EisPackage.eINSTANCE.statement_Variable,
							MULTIPLE_STATEMENT_ASSIGNMENT)
						error("Multiple variable assignment", d, EisPackage.eINSTANCE.statement_Cascade,
							MULTIPLE_STATEMENT_ASSIGNMENT)
					}
				}
			}
		}
	}

	@Check def void checkMultipleStatementsAssertBlock(Assert asserts) {
		val assert = asserts.assertVariables
		val multiMap = HashMultimap.create()
		var name = ""

		// add all variables to the map
		for (e : assert) {
			if (e.cascade.empty)
				multiMap.put(e.variable.name, e)
			else {
				name = e.variable.name.toString
				for (c : e.cascade)
					name += '.' + c.udtVar.name.toString
				multiMap.put(name, e)
			}
		}

		// check for duplicates
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates) {
					if (d.cascade.empty)
						error("Multiple variable assignment", d, EisPackage.eINSTANCE.statement_Variable,
							MULTIPLE_STATEMENT_ASSIGNMENT)
					else {
						error("Multiple variable assignment", d, EisPackage.eINSTANCE.statement_Variable,
							MULTIPLE_STATEMENT_ASSIGNMENT)
						error("Multiple variable assignment", d, EisPackage.eINSTANCE.statement_Cascade,
							MULTIPLE_STATEMENT_ASSIGNMENT)
					}
				}
			}
		}
	}

	@Check def void checkRangeOperator(Variable variable) {
		val type = variable.variableType.typeFor

		if (variable.range !== null) {
			if (type.isWithoutRangeOp)
				error("The range feature is not permitted to this type", variable, EisPackage.eINSTANCE.variable_Range,
					INVALID_RANGE_DEFINITION)

			if (variable.directionBlock instanceof Input)
				error("The range feature is not permitted to input variables", variable,
					EisPackage.eINSTANCE.variable_Range, INVALID_RANGE_DEFINITION)
		}
	}

	@Check def void checkRangeOperator(Set set) {
		val sets = set.setVariables
		for (statement : sets)
			if (statement.range !== null)
				error("The range feature is not permitted to input variables", statement,
					EisPackage.eINSTANCE.statement_Range, INVALID_RANGE_DEFINITION)
	}

	@Check def void checkUniquePlcCycles(DefineBlock define) {
		var multiMap = HashMultimap.create
		// add all udtTypes of input to the multimap
		for (e : define?.teststeps)
			multiMap.put(e.plcCycle, e)

		// check for duplicates
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					error("Multiple plcCycle", d, EisPackage.eINSTANCE.teststepBlock_PlcCycle,
						EisValidator.MULTIPLE_PLCCYCLE)
			}
		}
	}

	@Check def void checkUniqueTestcaseNames(EisModel model) {
		var multiMap = HashMultimap.create
		// add all udtTypes of input to the multimap
		for (e : model?.testcases)
			multiMap.put(e.testcase_name, e)

		// check for duplicates
		for (entry : multiMap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					error("Multiple plcCycle", d, EisPackage.eINSTANCE.testcase_Testcase_name,
						EisValidator.MULTIPLE_TESTCASE_NAME)
			}
		}
	}

	@Check def void checkNumericalValues(Variable variable) {
		val expectedType = variable.variableType.typeFor
		val idiom = variable?.idiom
		val range = variable?.range

		if (idiom !== null)
			if (!(idiom instanceof VariableRef)) {
				val idiomValue = idiom.interpret
				if (idiomValue instanceof Long)
					if (idiomValue.checkNumericalValues(expectedType))
						error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.variable_Idiom,
							VALUE_EXCEEDING_DATATYPE_BOUNDS)
			}

		if (range !== null)
			if (!(range instanceof VariableRef)) {
				val rangeValue = range.interpret
				if (rangeValue instanceof Long)
					if (rangeValue.checkNumericalValues(expectedType))
						error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.variable_Range,
							VALUE_EXCEEDING_DATATYPE_BOUNDS)
			}
	}

	@Check def void checkValuesOfStatements(Statement statement) {
		val cascade = statement.cascade
		val variable = statement.variable
		val last = cascade?.last?.udtVar

		val idiom = statement?.idiom
		val range = statement?.range
		var expectedType = BasicType.NULL.typeFor

		if (variable instanceof Variable) {
			expectedType = variable.variableType.typeFor

			if (!(idiom instanceof VariableRef)) {
				val idiomValue = idiom.interpret
				if (idiomValue instanceof Long) {
					if (idiomValue.checkNumericalValues(expectedType))
						error("Value is out of the datatype boundaries.", statement,
							EisPackage.eINSTANCE.statement_Idiom, VALUE_EXCEEDING_DATATYPE_BOUNDS)
				} else if (idiom.typeFor instanceof TimeType) {
					if (idiom.checkTime)
						error("Value is out of the datatype boundaries.", statement,
							EisPackage.eINSTANCE.statement_Idiom, VALUE_EXCEEDING_DATATYPE_BOUNDS)
					idiom.interpret.toString.checkUnderscoreNotation(statement, EisPackage.eINSTANCE.statement_Idiom)
				} else if (idiom.typeFor instanceof LTimeType) {
					if (idiom.isOutOfLTime)
						error("Value is out of the datatype boundaries.", statement,
							EisPackage.eINSTANCE.statement_Idiom, VALUE_EXCEEDING_DATATYPE_BOUNDS)
					idiom.interpret.toString.checkUnderscoreNotation(statement, EisPackage.eINSTANCE.statement_Idiom)
				} else if (idiom.typeFor instanceof DateType) {
					if (idiom.checkDate(EisPackage.eINSTANCE.statement_Idiom))
						error("Value is out of the datatype boundaries.", statement,
							EisPackage.eINSTANCE.statement_Idiom, VALUE_EXCEEDING_DATATYPE_BOUNDS)
				}
			}
			if (range !== null)
				if (!(range instanceof VariableRef)) {
					val rangeValue = range.interpret
					if (rangeValue instanceof Long) {
						if (rangeValue.checkNumericalValues(expectedType))
							error("Value is out of the datatype boundaries.", statement,
								EisPackage.eINSTANCE.statement_Range, VALUE_EXCEEDING_DATATYPE_BOUNDS)
					} else if (range.typeFor instanceof TimeType) {
						if (range.checkTime)
							error("Value is out of the datatype boundaries.", statement,
								EisPackage.eINSTANCE.statement_Range, VALUE_EXCEEDING_DATATYPE_BOUNDS)
						range.interpret.toString.checkUnderscoreNotation(statement,
							EisPackage.eINSTANCE.statement_Range)
					} else if (range.typeFor instanceof LTimeType) {
						if (range.isOutOfLTime)
							error("Value is out of the datatype boundaries.", statement,
								EisPackage.eINSTANCE.statement_Range, VALUE_EXCEEDING_DATATYPE_BOUNDS)
						range.interpret.toString.checkUnderscoreNotation(statement,
							EisPackage.eINSTANCE.statement_Range)
					}
				}
		} else if (last instanceof Variable) {
			expectedType = last.variableType.typeFor

			if (!(idiom instanceof VariableRef)) {
				val idiomValue = idiom.interpret
				if (idiomValue instanceof Long) {
					if (idiomValue.checkNumericalValues(expectedType))
						error("Value is out of the datatype boundaries.", statement,
							EisPackage.eINSTANCE.statement_Idiom, VALUE_EXCEEDING_DATATYPE_BOUNDS)
				} else if (idiom.typeFor instanceof TimeType) {
					if (idiom.checkTime)
						error("Value is out of the datatype boundaries.", statement,
							EisPackage.eINSTANCE.statement_Idiom, VALUE_EXCEEDING_DATATYPE_BOUNDS)
					idiom.interpret.toString.checkUnderscoreNotation(statement, EisPackage.eINSTANCE.statement_Idiom)
				} else if (idiom.typeFor instanceof LTimeType) {
					if (idiom.isOutOfLTime)
						error("Value is out of the datatype boundaries.", statement,
							EisPackage.eINSTANCE.statement_Idiom, VALUE_EXCEEDING_DATATYPE_BOUNDS)
					idiom.interpret.toString.checkUnderscoreNotation(statement, EisPackage.eINSTANCE.statement_Idiom)
				} else if (idiom.typeFor instanceof DateType) {
					if (idiom.checkDate(EisPackage.eINSTANCE.statement_Idiom))
						error("Value is out of the datatype boundaries.", statement,
							EisPackage.eINSTANCE.statement_Idiom, VALUE_EXCEEDING_DATATYPE_BOUNDS)
				}
			}
			if (range !== null)
				if (!(range instanceof VariableRef)) {
					val rangeValue = range.interpret
					if (rangeValue instanceof Long) {
						if (rangeValue.checkNumericalValues(expectedType))
							error("Value is out of the datatype boundaries.", statement,
								EisPackage.eINSTANCE.statement_Range, VALUE_EXCEEDING_DATATYPE_BOUNDS)
					} else if (range.typeFor instanceof TimeType) {
						if (range.checkTime)
							error("Value is out of the datatype boundaries.", statement,
								EisPackage.eINSTANCE.statement_Range, VALUE_EXCEEDING_DATATYPE_BOUNDS)
						range.interpret.toString.checkUnderscoreNotation(statement,
							EisPackage.eINSTANCE.statement_Range)
					} else if (range.typeFor instanceof LTimeType) {
						if (range.isOutOfLTime)
							error("Value is out of the datatype boundaries.", statement,
								EisPackage.eINSTANCE.statement_Range, VALUE_EXCEEDING_DATATYPE_BOUNDS)

						range.interpret.toString.checkUnderscoreNotation(statement,
							EisPackage.eINSTANCE.statement_Range)
					}
				}
		}
	}

	@Check def void checkTimeValues(Variable variable) {
		val idiom = variable?.idiom
		val range = variable?.range

		if (idiom !== null)
			if (!(idiom instanceof VariableRef)) {
				if (idiom.typeFor instanceof TimeType) {
					if (idiom.checkTime)
						error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.variable_Idiom,
							VALUE_EXCEEDING_DATATYPE_BOUNDS)
					idiom.interpret.toString.checkUnderscoreNotation(variable, EisPackage.eINSTANCE.variable_Idiom)
				} else if (idiom.typeFor instanceof LTimeType) {
					if (idiom.isOutOfLTime)
						error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.variable_Idiom,
							VALUE_EXCEEDING_DATATYPE_BOUNDS)
					idiom.interpret.toString.checkUnderscoreNotation(variable, EisPackage.eINSTANCE.variable_Idiom)
				}
			}

		if (range !== null)
			if (!(range instanceof VariableRef)) {
				if (range.typeFor instanceof TimeType) {
					if (range.checkTime)
						error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.variable_Range,
							VALUE_EXCEEDING_DATATYPE_BOUNDS)
					range.interpret.toString.checkUnderscoreNotation(variable, EisPackage.eINSTANCE.variable_Range)
				} else if (range.typeFor instanceof LTimeType) {
					if (range.isOutOfLTime)
						error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.variable_Range,
							VALUE_EXCEEDING_DATATYPE_BOUNDS)
					range.interpret.toString.checkUnderscoreNotation(variable, EisPackage.eINSTANCE.variable_Range)
				}
			}
	}

	@Check def void checkDateValues(Variable variable) {
		val idiom = variable?.idiom

		if (idiom !== null)
			if (!(idiom instanceof VariableRef)) {
				if (idiom.typeFor instanceof DateType) {
					if (idiom.checkDate(EisPackage.eINSTANCE.variable_Idiom))
						error("Value is out of the datatype boundaries.", variable, EisPackage.eINSTANCE.variable_Idiom,
							VALUE_EXCEEDING_DATATYPE_BOUNDS)
				}
			}
	}

	@Check def void checkRealValues(Variable variable) {
		val type = variable.variableType?.toString
		val idiom = variable?.idiom
		val range = variable?.range

		if (idiom !== null)
			if (!(idiom instanceof VariableRef)) {
				if (idiom.typeFor instanceof RealType)
					if (type === "real") {
						if ((idiom.interpret as Double).checkRealValue)
							error("Value is out of the datatype boundaries.", variable,
								EisPackage.eINSTANCE.variable_Idiom, VALUE_EXCEEDING_DATATYPE_BOUNDS)
					} else if (type === "lreal") {
						if ((idiom.interpret as Double).checkLRealValue)
							error("Value is out of the datatype boundaries.", variable,
								EisPackage.eINSTANCE.variable_Idiom, VALUE_EXCEEDING_DATATYPE_BOUNDS)
					}
			}

		if (range !== null)
			if (!(range instanceof VariableRef)) {
				if (range.typeFor instanceof RealType)
					if (type === "real") {
						if ((range.interpret as Double).checkRealValue)
							error("Value is out of the datatype boundaries.", variable,
								EisPackage.eINSTANCE.variable_Range, VALUE_EXCEEDING_DATATYPE_BOUNDS)
					} else if (type === "lreal") {
						if ((range.interpret as Double).checkLRealValue)
							error("Value is out of the datatype boundaries.", variable,
								EisPackage.eINSTANCE.variable_Range, VALUE_EXCEEDING_DATATYPE_BOUNDS)
					}
			}
	}

	def boolean checkLRealValue(Double _double) {
		if (_double.infinite)
			return true

		var doubleAsString = _double.toString

		if (doubleAsString.contains('e') || doubleAsString.contains('E')) {
			val uDoubleMin = 2.2250738585072014 // uDoubleMax is not necessary because the numer is infinite
			val uMaxExponent = 308

			var exponent = doubleAsString.replace('e', 'E').split('E').last
			val negativeExponent = exponent.contains('-')

			exponent = exponent.replace('-', '+').replace('+', '')

			val exponentAsInt = Integer.parseInt(exponent)
			if (exponentAsInt > uMaxExponent)
				return true
			if (exponentAsInt == uMaxExponent) {
				val beforeExponentAsString = doubleAsString.replace('e', 'E').split('E').head.replace('-', '')
				val beforeExponent = Double.parseDouble(beforeExponentAsString)

				if (beforeExponent < uDoubleMin && negativeExponent)
					return true
			}
		}

		return false
	}

	def checkRealValue(Double _double) {
		if(_double.infinite) return true
		var doubleAsString = _double.toString
		// note the fact that if too many digits behind the comma are defined the parser will round the 15th or 16th digit -> unknown behaviour
		// also when both long numbers are in front and behind the comma -> unknown behaviour
		if (doubleAsString.contains('e') || doubleAsString.contains('E')) {
			val uDoubleMax = 3.402823
			val uDoubleMin = 1.175495
			val uMaxExponent = 38

			var exponent = doubleAsString.replace('e', 'E').split('E').last
			val negativeExponent = exponent.contains('-')

			exponent = exponent.replace('-', '+').replace('+', '')

			val exponentAsInt = Integer.parseInt(exponent)

			if (exponentAsInt > uMaxExponent)
				return true
			if (exponentAsInt == uMaxExponent) {
				val beforeExponentAsString = doubleAsString.replace('e', 'E').split('E').head.replace('-', '')
				val beforeExponent = Double.parseDouble(beforeExponentAsString)
				if (beforeExponent > uDoubleMax && !negativeExponent) {
					return true
				} else if (beforeExponent < uDoubleMin && negativeExponent) {
					return true
				}
			}
		}

		return false
	}

//
// methods -----------------------------------------------------------------------------------------------------------------------------------------------------------------
//
	def boolean checkDate(Idiom _date, EReference ref) {
		val date = _date.interpret.toString.substring(2) // Format: YYYY-MM-DD
		val dateAsInt = Integer.parseInt(date.replaceAll('-', ''))
		val upperBound = 21690606
		val lowerBound = 19900101

		try {
			LocalDate.parse(date, DateTimeFormatter.ISO_LOCAL_DATE);
		} catch (DateTimeParseException e) {
			error("Date could not be correctly parsed to the following format: YYYY-MM-DD ", _date.eContainer, ref,
				INVALID_DATE_NOTATION)
			return false
		}

		if (dateAsInt < lowerBound || dateAsInt > upperBound)
			return true
		else
			false
	}

//	def private EObject firstUdt(EObject context) {
//		val container = context.eContainer
//		if (container instanceof Udt)
//			container.firstUdt
//		else
//			return context
//	}
	def boolean checkTime(Idiom _time) {
		var time = _time.interpret.toString.substring(2).replaceAll('_', '')

		var ms = ''
		var s = ''
		var m = ''
		var h = ''
		var d = ''
		var sign = ''

		if (time.contains('-')) {
			sign = '-'
			time = time.replace('-', '')
		}
		if (time.contains('ms')) {
			time = time.split('ms').head
			ms = time.lastNumber
		}
		if (time.contains('s')) {
			time = time.split('s').head
			s = time.lastNumber
		}
		if (time.contains('m')) {
			time = time.split('m').head
			m = time.lastNumber
		}
		if (time.contains('h')) {
			time = time.split('h').head
			h = time.lastNumber
		}
		if (time.contains('d')) {
			d = time.split('d').head
		}
//
//		rebuilding the time string
//
		time = sign + 'p'
		if(d != '') time += d + 'd'
		time += 't'
		if(h != '') time += h + 'h'
		if(m != '') time += m + 'm'
		if (s != '') {
			time += s
			if(ms != '') time += '.' + ms.fraction
			time += 's'
		} else if (ms != '')
			time += '0' + '.' + ms.fraction + 's'

		val duration = Duration.parse(time)
		val maxTime = Duration.parse("p24dt20h31m23,647s")
		val minTime = Duration.parse("-p24dt20h31m23,648s")

		if (maxTime.compareTo(duration) < 0) // (final_hour > t) => returns 1 if under maxTime
			return true
		else if (minTime.compareTo(duration) > 0) // (first_hour > t) => -1 if above minTime
			return true
		else
			false
	}

	def boolean isOutOfLTime(Idiom _ltime) {
		var LTime = _ltime.interpret.toString.substring(3).replaceAll('_', '')

		var ns = ''
		var us = ''
		var ms = ''
		var s = ''
		var m = ''
		var h = ''
		var d = ''
		var sign = ''

		if (LTime.contains('-')) {
			sign = '-'
			LTime = LTime.replace('-', '')
		}
		if (LTime.contains('ns')) {
			LTime = LTime.split('ns').head
			ns = LTime.lastNumber
		}
		if (LTime.contains('us')) {
			LTime = LTime.split('us').head
			us = LTime.lastNumber
		}
		if (LTime.contains('ms')) {
			LTime = LTime.split('ms').head
			ms = LTime.lastNumber
		}
		if (LTime.contains('s')) {
			LTime = LTime.split('s').head
			s = LTime.lastNumber
		}
		if (LTime.contains('m')) {
			LTime = LTime.split('m').head
			m = LTime.lastNumber
		}
		if (LTime.contains('h')) {
			LTime = LTime.split('h').head
			h = LTime.lastNumber
		}
		if (LTime.contains('d')) {
			d = LTime.split('d').head
		}
//
//		rebuilding the time string
//
		LTime = sign + 'p'
		if(d != '') LTime += d + 'd'
		LTime += 't'
		if(h != '') LTime += h + 'h'
		if(m != '') LTime += m + 'm'
		if (s != '') {
			LTime += s
			if(ns != '' || us != '' || ms != '') LTime += '.' + ms.fraction + us.fraction + ns.fraction
			LTime += 's'

		} else if (ns != '' || us != '' || ms != '')
			LTime += '0.' + ms.fraction + us.fraction + ns.fraction + 's'

		val duration = Duration.parse(LTime)
		val maxTime = Duration.parse("p106751dt23h47m16.854775807s")
		val minTime = Duration.parse("-p106751dt23h47m16.854775808s")

		if (maxTime.compareTo(duration) < 0) // (final_hour > t) => returns 1 if under maxTime
			return true
		else if (minTime.compareTo(duration) > 0) // (first_hour > t) => -1 if above minTime
			return true
		else
			false
	}

	def String lastNumber(String time) {
		var i = 1
		var last = ""
		while (time.charAt(time.length - i).toString.isNumerical) {
			if (i < time.length)
				i++
			else // avoid endless loop
				return time
		}
		for (i--; i > 0; i--) {
			last += time.charAt(time.length - i).toString
		}
		return last
	}

	def boolean isNumerical(String _char) {
		if (_char.toUpperCase.equals(_char.toLowerCase))
			true
		else
			false
	}

	def String fraction(String value) {
		if (value.length == 3)
			return value
		if (value.length == 2)
			return '0' + value
		if (value.length == 1)
			return '00' + value
		if (value.length == 0)
			return '000'
	}

	def private void checkUnderscoreNotation(String string, EObject object, EReference reference) {
		val lastChar = string.charAt(string.length - 1)
		if (lastChar.toString.equals('_'))
			error("Invalid underscore notation.", object, reference, INVALID_UNDERSCORE_NOTATION)
	}

	def private boolean checkNumericalValues(long idiom, DefineType expectedType) {
		switch expectedType {
			case expectedType.isUSIntType: idiom.isOutOfNumericalBounds(0, 255)
			case expectedType.isUIntType: idiom.isOutOfNumericalBounds(0, 65535)
			case expectedType.isUDIntType: idiom.isOutOfNumericalBounds(0, 4294967295L)
			case expectedType.isULIntType: if(idiom.intValue < 0) true else false
			case expectedType.isSIntType: idiom.isOutOfNumericalBounds(-128, 127)
			case expectedType.isIntType: idiom.isOutOfNumericalBounds(-32768, 32767)
			case expectedType.isDIntType: idiom.isOutOfNumericalBounds(-2147483647, 2147483647) // the xtend (java) int is a 32-Bit-Int
			default: false
		}
	}

	def private boolean isOutOfNumericalBounds(long idiom, int lower, long upper) {
		var outOfBounds = false

		if (idiom < lower || idiom > upper)
			outOfBounds = true

		return outOfBounds
	}

	def private EObject directionBlock(EObject context) {
		val container = context.eContainer
		if (container instanceof DirectionBlock)
			return context
		else
			container.directionBlock
	}

	def private void checkVariableTypeAndAddToMap(
		Variables e,
		HashMultimap<String, Variables> multiMap
	) {
		if (e instanceof Udt) {
			multiMap.put(e.name, e)
		} else if (e instanceof Variable)
			multiMap.put(e.name, e)
	}

	def private void checkAllVariableNamesInUdtScope(Udt udt) {
		val newMultimap = HashMultimap.create
		val udts = udt.udtVariables

		for (e : udts) {
			e.checkVariableTypeAndAddToMap(newMultimap)
			if (e instanceof Udt)
				e.checkAllVariableNamesInUdtScope
		}
		// check for duplicates
		for (entry : newMultimap.asMap.entrySet) {
			val duplicates = entry.value
			if (duplicates.size > 1) {
				for (d : duplicates)
					d.checkVariableTypeAndCallError
			}
		}
	}

	def private void checkVariableTypeAndCallError(Variables e) {
		if (e instanceof Udt)
			error("Multiple variable name '" + e.name + "'", e, EisPackage.eINSTANCE.variables_Name,
				EisValidator.MULTIPLE_UDT_DECLARATION)
		else if (e instanceof Variable)
			error("Multiple variable name '" + e.name + "'", e, EisPackage.eINSTANCE.variables_Name,
				EisValidator.MULTIPLE_VARIABLE_DECLARATION)
	}

	def private void checkNoDuplicateUdtTypes(Udt udt) {
		var multiMap = HashMultimap.create
		val udts = udt.udtVariables

		for (e : udts) {
			if (e instanceof Udt) {
				multiMap.put(e.udtType.name, e)
				e.checkNoDuplicateUdtTypes
			}
		}
	}

	def private void checkExpectedBoolean(Idiom exp, EReference reference) {
		checkExpectedType(exp, DefineTypeComputer.BOOL_TYPE, reference)
	}

	def private void checkExpectedInt(Idiom exp, EReference reference) {
		checkExpectedType(exp, DefineTypeComputer.INT_TYPE, reference)
	}

	def private void checkExpectedDouble(Idiom exp, EReference reference) {
		checkExpectedType(exp, DefineTypeComputer.REAL_TYPE, reference)
	}

	def private void checkExpectedType(Idiom exp, DefineType expectedType, EReference reference) {
		val actualType = getTypeAndCheckNotNull(exp, reference)
		if (actualType != expectedType)
			error("expected " + expectedType + " type, but was " + actualType, reference, TYPE_MISMATCH)
	}

	def private DefineType getTypeAndCheckNotNull(Idiom exp, EReference reference) {
		var type = exp?.typeFor
		if (type === null)
			error("null type", reference, TYPE_MISMATCH)
		return type;
	}

	def private void checkExpectedSameType(DefineType left, DefineType right) {
		if (right !== null && left !== null && right != left)
			error("expected the same type, but was " + left + ", " + right, EisPackage.Literals.EQUALITY.EIDAttribute,
				TYPE_MISMATCH)
	}

	def private void checkNotBoolean(DefineType type, EReference reference) {
		if (type.isBoolType)
			error("cannot be boolean", reference, TYPE_MISMATCH)
	}

	def private void compareTypesAndCallErrorOnMismatch(Statement statement, DefineType actualType,
		BasicType _expectedType, DefineType rangeType) {
		val expectedType = _expectedType.typeFor

		if (actualType != expectedType)
			if (!(actualType.isIntSuperType && expectedType.isIntSuperType ))
				error("Incompatible types. Expected '" + expectedType.toString + "' but was '" + actualType.toString +
					"'", statement, EisPackage.eINSTANCE.statement_Idiom, INCOMPATIBLE_TYPES)
		if (rangeType !== null && rangeType != expectedType)
			if (!(rangeType.isIntSuperType && expectedType.isIntSuperType ))
				error("Incompatible types. Expected '" + expectedType.toString + "' but was '" + rangeType.toString +
					"'", statement, EisPackage.eINSTANCE.statement_Range, INCOMPATIBLE_TYPES)
	}

	def private void checkCommaSyntaxWithVariables(Iterable<? extends Variables> variables) {

		var count = 0 // ugly programming
		var countOfVariableBefore = 0
		var commaBeforeVariable = false;
		var helpingVariableType = BasicType.NULL
		var variantKeyword = false

		for (e : variables) {

			if (e instanceof Udt) {
				if (!e.udtVariables.empty)
					checkCommaSyntaxWithVariables(e.udtVariables)
			}

			// refer error to the last variable which was succeeded by a comma
			if (commaBeforeVariable && !(e instanceof Variable)) {
				error("Invalid comma. Semicolon expected.", variables.get(countOfVariableBefore),
					EisPackage.eINSTANCE.variable_NextVariable, INVALID_COMMA_NOTATION)
			}

			if (e instanceof Variable) {
				//
				if ((count - countOfVariableBefore) > 1) {
					// this checks the case if there's a udt type between a comma and the expected inferred type
					commaBeforeVariable = false
				}

				if (!commaBeforeVariable) {
					if (e.variableType === BasicType.NULL) {
						error("Missing variable type", e, EisPackage.eINSTANCE.variable_VariableType,
							MISSING_VARIABLE_TYPE);
					}
				} //
				// else if there was a comma before the variable
				else {
					// assign inferred type 								
					if (e.variableType === BasicType.NULL) {
						e.variableType = helpingVariableType
					} else {
						if (helpingVariableType !== e.variableType)
							error("Multiple type definition", e, EisPackage.eINSTANCE.variable_VariableType,
								MULTIPLE_TYPE_DEFINITION)
					}
					if (e.variantKeyword && !variantKeyword)
						error("Invalid variant keyword", e, EisPackage.eINSTANCE.variable_VariantKeyword,
							INVALID_VARIANT_KEYWORD)
					else // assign variantKeyword
						e.variantKeyword = variantKeyword

				}
// for the immediate next variable
				if (e.nextVariable) { // comma at the end instead of semicolon
					commaBeforeVariable = true;
					countOfVariableBefore = count;

					// the type must be handed over to the next variable
					helpingVariableType = e.variableType

				} else {
					commaBeforeVariable = false
					helpingVariableType = null

				}
				// the variant as well	
				variantKeyword = e.variantKeyword
			}
			count++
		}
		// check if the last/only variable ends with a comma
		val last = variables.last
		if (last instanceof Variable)
			if (last.nextVariable)
				error("Invalid comma. Semicolon expected.", last, EisPackage.eINSTANCE.variable_NextVariable,
					INVALID_COMMA_NOTATION)
	}

	def private Variable assignNewVariable(Iterable<? extends Variables> referredUdtVars, int count) {
		var newVariable = new VariableImpl
		val variable = (referredUdtVars.get(count) as Variable)

		newVariable.name = variable.name
		newVariable.variableType = variable.variableType
		newVariable.variantKeyword = variable.isVariantKeyword
		newVariable.nextVariable = variable.isNextVariable

		if ((variable.idiom instanceof VariableRef) || (variable.range instanceof VariableRef))
			error("This reference cannot be made because a variable contains other references ", // udtRef,
			EisPackage.eINSTANCE.udtRef_UdtType, RECURSIVE_VARIABLE_REFERENCE)
		else {
			val type = newVariable.variableType.typeFor

			if (variable?.idiom !== null)
				switch type {
					case type.isStringType: {
						newVariable.idiom = new StringConstantImpl;
						(newVariable.idiom as StringConstant).value = variable?.idiom?.interpret?.toString
					}
					case type.isBoolType: {
						newVariable.idiom = new BoolConstantImpl;
						(newVariable.idiom as BoolConstant).value = variable?.idiom?.interpret?.toString
					}
					case type.isIntSuperType: {
						newVariable.idiom = new IntConstantImpl;
						(newVariable.idiom as IntConstant).value = variable?.idiom?.interpret as Long
					}
				}

			if (variable?.range !== null)
				switch type {
					case type.isStringType: {
						newVariable.range = new StringConstantImpl;
						(newVariable.range as StringConstant).value = variable?.range?.interpret?.toString
					}
					case type.isBoolType: {
						newVariable.range = new BoolConstantImpl;
						(newVariable.range as BoolConstant).value = variable?.range?.interpret?.toString
					}
					case type.isIntSuperType: {
						newVariable.range = new IntConstantImpl;
						(newVariable.range as IntConstant).value = (variable?.range?.interpret as Long)
					}
				}
		}

		return newVariable
	}

	def private Udt assignNewUdt(Iterable<? extends Variables> referredUdtVars, int count) {
		var newUdt = new UdtImpl
		val childRef = (referredUdtVars.get(count) as Udt)
		val childRefVars = childRef.udtVariables
		var count2 = 0

		newUdt.name = childRef.name
		newUdt.udtType = childRef.udtType

		if (!childRefVars.empty) {
			for (e : childRefVars) {
				if (e instanceof Variable) {
					newUdt.udtVariables.add(assignNewVariable(childRefVars, count2))
				} else if (e instanceof Udt) {
					newUdt.udtVariables.add(assignNewUdt(childRefVars, count2))
				} else if (e instanceof UdtRef) {
					error("This reference cannot be made because the udt itself contains other references ",
						(e as UdtRef), EisPackage.eINSTANCE.udtRef_UdtType, RECURSIVE_UDT_REFERENCE)
				}
				count2++
			}
		}

		return newUdt
	}

//
// yet unimplemented -----------------------------------------------------------------------------------------------------------------------------------------------------------------
//
	@Check def void checkUppercaseVariantName() {}

	@Check def void checkUppercaseUdtName() {}

	@Check def void checkLowercaseUdtType() {}

}
